/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import * as vscode from 'vscode';
import * as pty from '@homebridge/node-pty-prebuilt-multiarch';
import {
  TerminalInstance,
  TerminalEvent,
  TerminalState,
  TerminalInfo,
  DeleteResult,
} from '../types/common';
import { TERMINAL_CONSTANTS, ERROR_MESSAGES } from '../constants';
import { ShellIntegrationService } from '../services/ShellIntegrationService';
import { terminal as log } from '../utils/logger';
import {
  getTerminalConfig,
  getShellForPlatform,
  getWorkingDirectory,
  generateTerminalId,
  generateTerminalName,
  showErrorMessage,
  showWarningMessage,
  ActiveTerminalManager,
  getFirstValue,
} from '../utils/common';
import { TerminalNumberManager } from '../utils/TerminalNumberManager';
import { CliAgentDetectionService } from '../services/CliAgentDetectionService';
import { ICliAgentDetectionService } from '../interfaces/CliAgentService';
import {
  TerminalLifecycleManager,
  ITerminalLifecycleManager,
} from '../services/TerminalLifecycleManager';
import {
  TerminalDataBufferingService,
  ITerminalDataBufferingService,
} from '../services/TerminalDataBufferingService';
import { TerminalStateManager, ITerminalStateManager } from '../services/TerminalStateManager';

export class TerminalManager {
  private readonly _terminals = new Map<string, TerminalInstance>();
  private readonly _activeTerminalManager = new ActiveTerminalManager();
  private readonly _dataEmitter = new vscode.EventEmitter<TerminalEvent>();
  private readonly _exitEmitter = new vscode.EventEmitter<TerminalEvent>();
  private readonly _terminalCreatedEmitter = new vscode.EventEmitter<TerminalInstance>();
  private readonly _terminalRemovedEmitter = new vscode.EventEmitter<string>();
  private readonly _stateUpdateEmitter = new vscode.EventEmitter<TerminalState>();
  private readonly _terminalFocusEmitter = new vscode.EventEmitter<string>();
  private readonly _terminalNumberManager: TerminalNumberManager;
  private _shellIntegrationService: ShellIntegrationService | null = null;
  // CLI Agent Detection Service (extracted for SRP)
  private readonly _cliAgentService: ICliAgentDetectionService;

  // Êìç‰Ωú„ÅÆÈ†ÜÂ∫è‰øùË®º„ÅÆ„Åü„ÇÅ„ÅÆ„Ç≠„É•„Éº
  private operationQueue: Promise<void> = Promise.resolve();

  // Track terminals being killed to prevent infinite loops
  private readonly _terminalBeingKilled = new Set<string>();

  // Performance optimization: Data batching for high-frequency output
  private readonly _dataBuffers = new Map<string, string[]>();
  private readonly _dataFlushTimers = new Map<string, NodeJS.Timeout>();
  private readonly DATA_FLUSH_INTERVAL = 8; // ~125fps for improved responsiveness
  private readonly MAX_BUFFER_SIZE = 50;

  // CLI Agent detection moved to service - cache removed from TerminalManager

  public readonly onData = this._dataEmitter.event;
  public readonly onExit = this._exitEmitter.event;
  public readonly onTerminalCreated = this._terminalCreatedEmitter.event;
  public readonly onTerminalRemoved = this._terminalRemovedEmitter.event;
  public readonly onStateUpdate = this._stateUpdateEmitter.event;
  public readonly onTerminalFocus = this._terminalFocusEmitter.event;

  constructor(cliAgentService?: ICliAgentDetectionService) {
    // Initialize terminal number manager with max terminals config
    const config = getTerminalConfig();
    this._terminalNumberManager = new TerminalNumberManager(config.maxTerminals);

    // Initialize CLI Agent detection service
    this._cliAgentService = cliAgentService || new CliAgentDetectionService();

    // üö® FIX: Start heartbeat mechanism for state validation
    this._cliAgentService.startHeartbeat();
  }

  /**
   * Get CLI Agent status change event
   */
  public get onCliAgentStatusChange(): vscode.Event<{
    terminalId: string;
    status: 'connected' | 'disconnected' | 'none';
    type: string | null;
    terminalName?: string;
  }> {
    return this._cliAgentService.onCliAgentStatusChange;
  }

  public createTerminal(): string {
    log('üîç [TERMINAL] === CREATE TERMINAL CALLED ===');

    const config = getTerminalConfig();
    log(`üîç [TERMINAL] Config loaded: maxTerminals=${config.maxTerminals}`);

    log(`üîç [TERMINAL] Current terminals count: ${this._terminals.size}`);
    
    // Force debug the actual terminal state before validation
    log('üîç [TERMINAL] Current terminals in map:', this._terminals.size);
    for (const [id, terminal] of this._terminals.entries()) {
      log(`üîç [TERMINAL] Map entry: ${id} -> ${terminal.name} (number: ${terminal.number})`);
    }
    
    // üö® CRITICAL DEBUG: Detailed canCreate analysis
    log('üîç [TERMINAL] === DETAILED canCreate() ANALYSIS ===');
    log('üîç [TERMINAL] this._terminals.size:', this._terminals.size);
    log('üîç [TERMINAL] config.maxTerminals:', config.maxTerminals);
    
    // Call canCreate and get detailed information
    const canCreateResult = this._terminalNumberManager.canCreate(this._terminals);
    log('üîç [TERMINAL] canCreate() returned:', canCreateResult);
    
    if (!canCreateResult) {
      log('üö® [TERMINAL] Cannot create terminal: all slots used');
      log('üö® [TERMINAL] Final canCreate check failed - investigating...');
      
      // Force re-check the numbers manually
      const usedNumbers = new Set<number>();
      log('üö® [TERMINAL] Analyzing each terminal in map:');
      for (const [id, terminal] of this._terminals.entries()) {
        log(`üö® [TERMINAL] Terminal ${id}:`, {
          name: terminal.name,
          number: terminal.number,
          hasValidNumber: typeof terminal.number === 'number' && !isNaN(terminal.number)
        });
        
        if (terminal.number && typeof terminal.number === 'number') {
          usedNumbers.add(terminal.number);
        }
      }
      log('üö® [TERMINAL] Used numbers from current terminals:', Array.from(usedNumbers));
      log('üö® [TERMINAL] Available slots should be:', Array.from({length: config.maxTerminals}, (_, i) => i + 1).filter(n => !usedNumbers.has(n)));
      
      // üö® CRITICAL: If terminals map is empty but canCreate returns false, there's a bug
      if (this._terminals.size === 0) {
        log('üö®üö®üö® [TERMINAL] CRITICAL BUG: No terminals exist but canCreate returned FALSE!');
        log('üö®üö®üö® [TERMINAL] This should NEVER happen - forcing creation');
        // Don't return early - continue with creation
      } else {
        showWarningMessage(`${ERROR_MESSAGES.MAX_TERMINALS_REACHED} (${config.maxTerminals})`);
        return this._activeTerminalManager.getActive() || '';
      }
    } else {
      log('‚úÖ [TERMINAL] canCreate() returned TRUE - proceeding with creation');
    }

    log('üîç [TERMINAL] Finding available terminal number...');
    const terminalNumber = this._terminalNumberManager.findAvailableNumber(this._terminals);
    log(`üîç [TERMINAL] Found available terminal number: ${terminalNumber}`);

    log('üîç [TERMINAL] Generating terminal ID...');
    const terminalId = generateTerminalId();
    log(`üîç [TERMINAL] Generated terminal ID: ${terminalId}`);

    const shell = getShellForPlatform(config.shell);
    const shellArgs = config.shellArgs;
    const cwd = getWorkingDirectory();

    log(`üîç [TERMINAL] Creating terminal: ID=${terminalId}, Shell=${shell}, CWD=${cwd}`);

    try {
      // Prepare environment variables with explicit PWD
      const env = {
        ...process.env,
        PWD: cwd,
        // Add VS Code workspace information if available
        ...(vscode.workspace.workspaceFolders &&
          vscode.workspace.workspaceFolders.length > 0 && {
            VSCODE_WORKSPACE: vscode.workspace.workspaceFolders[0]?.uri.fsPath || '',
            VSCODE_PROJECT_NAME: vscode.workspace.workspaceFolders[0]?.name || '',
          }),
      } as { [key: string]: string };

      const ptyProcess = pty.spawn(shell, shellArgs, {
        name: 'xterm-256color',
        cols: TERMINAL_CONSTANTS.DEFAULT_COLS,
        rows: TERMINAL_CONSTANTS.DEFAULT_ROWS,
        cwd,
        env: {
          ...env,
          // Ensure proper UTF-8 encoding for Japanese characters
          LANG: env.LANG || 'en_US.UTF-8',
          LC_ALL: env.LC_ALL || 'en_US.UTF-8',
          LC_CTYPE: env.LC_CTYPE || 'en_US.UTF-8',
          // Enhanced CLI compatibility flags
          FORCE_COLOR: '1',
          TERM: 'xterm-256color',
          COLORTERM: 'truecolor',
          // TEMPORARY: Remove PS1 override to debug input issue
          // PS1: env.PS1 || '\\u@\\h:\\w\\$ ',
        },
        encoding: 'utf8',
      });

      const terminal: TerminalInstance = {
        id: terminalId,
        pty: ptyProcess,
        ptyProcess: ptyProcess,
        name: generateTerminalName(terminalNumber),
        number: terminalNumber,
        cwd: cwd,
        isActive: true,
        createdAt: Date.now(),
      };

      // Set all other terminals as inactive
      this._deactivateAllTerminals();

      this._terminals.set(terminalId, terminal);
      this._activeTerminalManager.setActive(terminalId);

      ptyProcess.onData((data: string) => {
        // üîç DEBUGGING: Log all PTY data to identify shell prompt issues
        log(
          `üì§ [PTY-DATA] Terminal ${terminalId} received ${data.length} chars:`,
          JSON.stringify(data.substring(0, 100))
        );

        // Process shell integration sequences if service is available
        try {
          if (this._shellIntegrationService) {
            this._shellIntegrationService.processTerminalData(terminalId, data);
          }
        } catch (error) {
          log(`‚ö†Ô∏è [TERMINAL] Shell integration processing error: ${error}`);
        }

        // Performance optimization: Batch small data chunks
        this._bufferData(terminalId, data);
      });

      ptyProcess.onExit((event: number | { exitCode: number; signal?: number }) => {
        const exitCode = typeof event === 'number' ? event : event.exitCode;
        const signal = typeof event === 'object' ? event.signal : undefined;
        log(
          'üö™ [DEBUG] PTY process exited:',
          exitCode,
          'signal:',
          signal,
          'for terminal:',
          terminalId
        );

        // üõ°Ô∏è „Éó„É≠„Çª„ÇπÁµÇ‰∫Ü„Ç§„Éô„É≥„ÉàÔºàCLI AgentÁµÇ‰∫ÜÊ§úÂá∫„ÇíÂê´„ÇÄÔºâ
        // Handle CLI agent termination on process exit
        this._cliAgentService.handleTerminalRemoved(terminalId);

        // Check if this terminal is being manually killed to prevent infinite loop
        if (this._terminalBeingKilled.has(terminalId)) {
          log('üóëÔ∏è [DEBUG] Terminal exit triggered by manual kill, cleaning up:', terminalId);
          this._terminalBeingKilled.delete(terminalId);
          this._cleanupTerminalData(terminalId);
        } else {
          log('üö™ [DEBUG] Terminal exited naturally, removing:', terminalId);
          this._exitEmitter.fire({ terminalId, exitCode });
          this._removeTerminal(terminalId);
        }
      });

      log(`‚úÖ [TERMINAL] Terminal created successfully: ${terminal.name} (${terminalId})`);

      this._terminalCreatedEmitter.fire(terminal);

      // Initialize terminal with minimal shell interaction
      setTimeout(() => {
        try {
          log(`üîç [TERMINAL] Initializing shell for: ${terminalId}`);
          
          // Inject shell integration if service is available
          // TEMPORARY: Disable shell integration to debug input issue
          // try {
          //   if (this._shellIntegrationService) {
          //     log(`üîß [TERMINAL] Injecting shell integration for: ${terminalId}`);
          //     this._shellIntegrationService.injectShellIntegration(terminalId, shell, ptyProcess);
          //   }
          // } catch (error) {
          //   log(`‚ö†Ô∏è [TERMINAL] Shell integration injection error: ${error}`);
          // }
          
          // Send only a single carriage return to trigger initial prompt
          ptyProcess.write('\r');
        } catch (error) {
          log(`‚ö†Ô∏è [TERMINAL] Failed to initialize shell for ${terminalId}:`, error);
        }
      }, 300); // 300ms delay to let shell initialize

      // Áä∂ÊÖãÊõ¥Êñ∞„ÇíÈÄöÁü•
      log('üîç [TERMINAL] Notifying state update...');
      this._notifyStateUpdate();
      log('üîç [TERMINAL] State update completed');

      log(`üîç [TERMINAL] === CREATE TERMINAL FINISHED: ${terminalId} ===`);
      return terminalId;
    } catch (error) {
      log(
        `‚ùå [TERMINAL] Error creating terminal: ${error instanceof Error ? error.message : String(error)}`
      );
      log(`‚ùå [TERMINAL] Error stack: ${error instanceof Error ? error.stack : 'No stack'}`);
      showErrorMessage(ERROR_MESSAGES.TERMINAL_CREATION_FAILED, error);
      throw error;
    }
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÁßª„Åô
   * üö® IMPORTANT: Focus should NOT change CLI Agent status (spec compliance)
   */
  public focusTerminal(terminalId: string): void {
    const terminal = this._terminals.get(terminalId);
    if (!terminal) {
      console.warn('‚ö†Ô∏è [WARN] Terminal not found for focus:', terminalId);
      return;
    }

    // üö® CRITICAL: „Éï„Ç©„Éº„Ç´„ÇπÂ§âÊõ¥„ÅØCLI AgentÁä∂ÊÖã„Å´ÂΩ±Èüø„Åó„Å™„ÅÑÔºà‰ªïÊßòÊõ∏Ê∫ñÊã†Ôºâ
    // Only fire focus event, do not change CLI Agent status
    this._terminalFocusEmitter.fire(terminalId);
    log(`üéØ [TERMINAL] Focused: ${terminal.name} (NO status change - spec compliant)`);
  }

  public sendInput(data: string, terminalId?: string): void {
    // ‚úÖ CRITICAL FIX: Robust terminal ID resolution with complete validation
    let resolvedTerminalId: string;

    if (terminalId) {
      // Use provided terminal ID, but validate it exists and is active
      if (!this._terminals.has(terminalId)) {
        console.error(`üö® [TERMINAL] Provided terminal ID does not exist: ${terminalId}`);
        console.log('üîç [TERMINAL] Available terminals:', Array.from(this._terminals.keys()));

        // Fallback to active terminal
        const activeId = this._activeTerminalManager.getActive();
        if (!activeId) {
          console.error('üö® [TERMINAL] No active terminal available as fallback');
          return;
        }
        resolvedTerminalId = activeId;
        console.warn(`‚ö†Ô∏è [TERMINAL] Using active terminal as fallback: ${resolvedTerminalId}`);
      } else {
        resolvedTerminalId = terminalId;
      }
    } else {
      // Get currently active terminal
      const activeId = this._activeTerminalManager.getActive();
      if (!activeId) {
        console.error('üö® [TERMINAL] No active terminal ID available');
        console.log('üîç [TERMINAL] Available terminals:', Array.from(this._terminals.keys()));
        return;
      }

      // Validate the active terminal still exists
      if (!this._terminals.has(activeId)) {
        console.error(`üö® [TERMINAL] Active terminal ID ${activeId} no longer exists`);

        // Emergency: Find first available terminal
        const availableTerminals = Array.from(this._terminals.keys());
        if (availableTerminals.length === 0) {
          console.error('üö® [TERMINAL] No terminals available at all');
          return;
        }

        const emergencyTerminal = availableTerminals[0];
        if (!emergencyTerminal) {
          console.error('üö® [TERMINAL] Emergency terminal is undefined');
          return;
        }
        this._activeTerminalManager.setActive(emergencyTerminal);
        resolvedTerminalId = emergencyTerminal;
        console.warn(
          `‚ö†Ô∏è [TERMINAL] Emergency fallback to first available terminal: ${resolvedTerminalId}`
        );
      } else {
        resolvedTerminalId = activeId;
      }
    }

    // ‚úÖ FINAL VALIDATION: Ensure terminal exists and get instance
    const terminal = this._terminals.get(resolvedTerminalId);
    if (!terminal) {
      console.error(`üö® [TERMINAL] Terminal resolution failed for ID: ${resolvedTerminalId}`);
      return;
    }

    console.log(
      `‚å®Ô∏è [TERMINAL] Sending input to ${terminal.name} (${resolvedTerminalId}): ${data.length} chars`
    );

    try {
      // CLI Agent „Ç≥„Éû„É≥„Éâ„ÇíÊ§úÂá∫
      this._cliAgentService.detectFromInput(resolvedTerminalId, data);

      // ‚úÖ ENHANCED: Robust PTY writing with comprehensive validation
      const result = this._writeToPtyWithValidation(terminal, data);
      if (!result.success) {
        console.error(`üö® [TERMINAL] PTY write failed for ${terminal.name}: ${result.error}`);

        // Attempt recovery with alternative PTY instance
        console.log(`üîÑ [TERMINAL] Attempting PTY recovery for ${terminal.name}...`);
        const recovered = this._attemptPtyRecovery(terminal, data);
        if (!recovered) {
          throw new Error(result.error || 'PTY write failed and recovery unsuccessful');
        }
        console.log(`‚úÖ [TERMINAL] PTY recovery successful for ${terminal.name}`);
      } else {
        console.log(`‚úÖ [TERMINAL] Input sent successfully to ${terminal.name}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(
        `‚ùå [TERMINAL] Critical error sending input to ${terminal.name}:`,
        errorMessage
      );

      // Enhanced error logging with complete terminal state
      console.error('‚ùå [TERMINAL] Terminal state at failure:', {
        id: terminal.id,
        name: terminal.name,
        number: terminal.number,
        isActive: terminal.isActive,
        hasPty: !!terminal.pty,
        hasPtyProcess: !!terminal.ptyProcess,
        ptyType: terminal.pty ? typeof terminal.pty : 'undefined',
        ptyProcessType: terminal.ptyProcess ? typeof terminal.ptyProcess : 'undefined',
        ptyWritable: terminal.pty ? typeof terminal.pty.write : 'no pty',
        ptyProcessWritable:
          terminal.ptyProcess &&
          typeof terminal.ptyProcess === 'object' &&
          'write' in terminal.ptyProcess
            ? typeof (terminal.ptyProcess as any).write
            : 'no ptyProcess',
        createdAt: terminal.createdAt,
        cwd: terminal.cwd,
      });

      showErrorMessage(`Terminal input failed for ${terminal.name}: ${errorMessage}`, error);
    }
  }

  public resize(cols: number, rows: number, terminalId?: string): void {
    const id = terminalId || this._activeTerminalManager.getActive();
    if (!id) {
      console.warn('‚ö†Ô∏è [WARN] No terminal ID provided and no active terminal for resize');
      return;
    }

    const terminal = this._terminals.get(id);
    if (!terminal) {
      console.warn('‚ö†Ô∏è [WARN] Terminal not found for resize:', id);
      return;
    }

    try {
      // Enhanced PTY resize with validation
      const result = this._resizePtyWithValidation(terminal, cols, rows);
      if (!result.success) {
        throw new Error(result.error || 'PTY resize failed');
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('‚ùå [ERROR] Failed to resize terminal:', errorMessage);
      console.error('‚ùå [ERROR] Resize parameters:', { cols, rows, terminalId: id });
    }
  }

  public hasActiveTerminal(): boolean {
    return this._activeTerminalManager.hasActive();
  }

  public getActiveTerminalId(): string | undefined {
    return this._activeTerminalManager.getActive();
  }

  public getTerminals(): TerminalInstance[] {
    return Array.from(this._terminals.values());
  }

  /**
   * Get a specific terminal by ID
   */
  public getTerminal(terminalId: string): TerminalInstance | undefined {
    return this._terminals.get(terminalId);
  }

  public setActiveTerminal(terminalId: string): void {
    const terminal = this._terminals.get(terminalId);
    if (terminal) {
      this._deactivateAllTerminals();
      terminal.isActive = true;
      this._activeTerminalManager.setActive(terminalId);
    }
  }

  public removeTerminal(terminalId: string): void {
    this._removeTerminal(terminalId);
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„ÅåÂâäÈô§ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÁµ±‰∏Ä„Åï„Çå„ÅüÊ§úË®º„É≠„Ç∏„ÉÉ„ÇØÔºâ
   */
  private _validateDeletion(terminalId: string): { canDelete: boolean; reason?: string } {
    if (!this._terminals.has(terminalId)) {
      return { canDelete: false, reason: 'Terminal not found' };
    }

    // ÊúÄ‰Ωé1„Å§„ÅÆ„Çø„Éº„Éü„Éä„É´„ÅØ‰øùÊåÅ„Åô„Çã
    if (this._terminals.size <= 1) {
      return { canDelete: false, reason: 'Must keep at least 1 terminal open' };
    }

    return { canDelete: true };
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„ÅåÂâäÈô§ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÂÖ¨ÈñãAPI„ÄÅÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÁ∂≠ÊåÅÔºâ
   */
  public canRemoveTerminal(terminalId: string): { canRemove: boolean; reason?: string } {
    const validation = this._validateDeletion(terminalId);
    return { canRemove: validation.canDelete, reason: validation.reason };
  }

  /**
   * ÂÆâÂÖ®„Å™„Çø„Éº„Éü„Éä„É´ÂâäÈô§ÔºàÂâäÈô§Ââç„ÅÆÊ§úË®º‰ªò„Åç„ÄÅÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÁ∂≠ÊåÅÔºâ
   * @deprecated Use deleteTerminal() instead
   */
  public safeRemoveTerminal(terminalId: string): boolean {
    const result = this.deleteTerminal(terminalId, { source: 'panel' });
    return result.then((r) => r.success).catch(() => false) as unknown as boolean;
  }

  /**
   * Áµ±‰∏Ä„Åï„Çå„Åü„Çø„Éº„Éü„Éä„É´ÂâäÈô§„É°„ÇΩ„ÉÉ„Éâ
   * ÊåáÂÆö„Åï„Çå„Åü„Çø„Éº„Éü„Éä„É´ID„ÇíÂâäÈô§„Åó„ÄÅÊñ∞„Åó„ÅÑÁä∂ÊÖã„ÇíËøî„Åô
   */
  public async deleteTerminal(
    terminalId: string,
    options: {
      force?: boolean;
      source?: 'header' | 'panel' | 'command';
    } = {}
  ): Promise<DeleteResult> {
    // Êìç‰Ωú„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†„Åó„Å¶„É¨„Éº„Çπ„Ç≥„É≥„Éá„Ç£„Ç∑„Éß„É≥„ÇíÈò≤„Åê
    return new Promise<DeleteResult>((resolve, reject) => {
      this.operationQueue = this.operationQueue.then(() => {
        try {
          const result = this.performDeleteOperation(terminalId, options);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  /**
   * „Ç¢„Éà„Éü„ÉÉ„ÇØ„Å™ÂâäÈô§Âá¶ÁêÜ
   */
  private performDeleteOperation(
    terminalId: string,
    options: {
      force?: boolean;
      source?: 'header' | 'panel' | 'command';
    }
  ): DeleteResult {
    log(
      `üóëÔ∏è [DELETE] Starting delete operation for terminal: ${terminalId} (source: ${options.source || 'unknown'})`
    );

    // 1. ÂâäÈô§Ââç„ÅÆÊ§úË®ºÔºàforce„Ç™„Éó„Ç∑„Éß„É≥„Åå„Å™„ÅÑÂ†¥ÂêàÔºâ
    if (!options.force) {
      const validation = this._validateDeletion(terminalId);
      if (!validation.canDelete) {
        log(`‚ö†Ô∏è [DELETE] Cannot delete terminal: ${validation.reason}`);
        showWarningMessage(validation.reason || 'Cannot delete terminal');
        return { success: false, reason: validation.reason };
      }
    }

    // 2. „Çø„Éº„Éü„Éä„É´„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    const terminal = this._terminals.get(terminalId);
    if (!terminal) {
      log(`‚ö†Ô∏è [DELETE] Terminal not found: ${terminalId}`);
      return { success: false, reason: 'Terminal not found' };
    }

    try {
      // 3. „Éó„É≠„Çª„Çπ„ÅÆÁµÇ‰∫Ü
      log(`üóëÔ∏è [DELETE] Killing terminal process: ${terminalId}`);
      this._terminalBeingKilled.add(terminalId);
      terminal.pty.kill();

      // 4. Áä∂ÊÖã„ÅÆÊõ¥Êñ∞„ÅØ onExit „Éè„É≥„Éâ„É©„ÅßË°å„Çè„Çå„Çã
      log(`‚úÖ [DELETE] Delete operation completed for: ${terminalId}`);

      // 5. Êñ∞„Åó„ÅÑÁä∂ÊÖã„ÇíËøî„Åô (ÈùûÂêåÊúü„Å™„ÅÆ„ÅßÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíËøî„Åô)
      return { success: true, newState: this.getCurrentState() };
    } catch (error) {
      log(`‚ùå [DELETE] Error during delete operation:`, error);
      this._terminalBeingKilled.delete(terminalId);
      return { success: false, reason: `Delete failed: ${String(error)}` };
    }
  }

  /**
   * ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
   */
  public getCurrentState(): TerminalState {
    const terminals: TerminalInfo[] = Array.from(this._terminals.values()).map((terminal) => ({
      id: terminal.id,
      name: terminal.name,
      isActive: terminal.isActive,
    }));

    return {
      terminals,
      activeTerminalId: this._activeTerminalManager.getActive() || null,
      maxTerminals: getTerminalConfig().maxTerminals,
      availableSlots: this._getAvailableSlots(),
    };
  }

  /**
   * Âà©Áî®ÂèØËÉΩ„Å™„Çπ„É≠„ÉÉ„Éà„ÇíÂèñÂæó
   */
  private _getAvailableSlots(): number[] {
    return this._terminalNumberManager.getAvailableSlots(this._terminals);
  }

  /**
   * WebView „Å´Áä∂ÊÖãÊõ¥Êñ∞„ÇíÈÄöÁü•
   */
  private _notifyStateUpdate(): void {
    const state = this.getCurrentState();
    this._stateUpdateEmitter.fire(state);
    log(`üì° [STATE] State update notification sent:`, state);
  }

  /**
   * ÂÆâÂÖ®„Å™„Çø„Éº„Éü„Éä„É´„Ç≠„É´ÔºàÂâäÈô§Ââç„ÅÆÊ§úË®º‰ªò„Åç„ÄÅÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÁ∂≠ÊåÅÔºâ
   * Â∏∏„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éº„Éü„Éä„É´„Çíkill„Åô„Çã
   * @deprecated Use deleteTerminal() with active terminal ID
   */
  public safeKillTerminal(terminalId?: string): boolean {
    const activeId = this._activeTerminalManager.getActive();
    if (!activeId) {
      const message = 'No active terminal to kill';
      console.warn('‚ö†Ô∏è [WARN]', message);
      showWarningMessage(message);
      return false;
    }

    if (terminalId && terminalId !== activeId) {
      log(
        'üîÑ [TERMINAL] Requested to safely kill:',
        terminalId,
        'but will kill active terminal:',
        activeId
      );
    }

    const result = this.deleteTerminal(activeId, { source: 'command' });
    return result.then((r) => r.success).catch(() => false) as unknown as boolean;
  }

  public killTerminal(terminalId?: string): void {
    // According to the spec: always kill the ACTIVE terminal, ignore provided ID
    const activeId = this._activeTerminalManager.getActive();
    if (!activeId) {
      console.warn('‚ö†Ô∏è [WARN] No active terminal to kill');
      showWarningMessage('No active terminal to kill');
      return;
    }

    if (terminalId && terminalId !== activeId) {
      log(
        'üîÑ [TERMINAL] Requested to kill:',
        terminalId,
        'but will kill active terminal:',
        activeId
      );
    }

    // Use unified delete method with force option
    this.deleteTerminal(activeId, { force: true, source: 'command' }).catch((error) => {
      console.error('‚ùå [TERMINAL] Error killing terminal:', error);
    });
  }

  /**
   * Set shell integration service after construction
   */
  public setShellIntegrationService(service: any): void {
    this._shellIntegrationService = service;
  }

  public dispose(): void {
    // Clean up data buffers and timers
    this._flushAllBuffers();
    for (const timer of this._dataFlushTimers.values()) {
      clearTimeout(timer);
    }
    this._dataBuffers.clear();
    this._dataFlushTimers.clear();

    // Clear kill tracking
    this._terminalBeingKilled.clear();

    // Dispose CLI Agent detection service
    this._cliAgentService.dispose();

    for (const terminal of this._terminals.values()) {
      terminal.pty.kill();
    }
    this._terminals.clear();
    this._dataEmitter.dispose();
    this._exitEmitter.dispose();
    this._terminalCreatedEmitter.dispose();
    this._terminalRemovedEmitter.dispose();
    this._stateUpdateEmitter.dispose();
    this._terminalFocusEmitter.dispose();
  }

  // Performance optimization: Buffer data to reduce event frequency
  private _bufferData(terminalId: string, data: string): void {
    // ‚úÖ CRITICAL FIX: Strict terminal ID validation to prevent cross-terminal contamination
    if (!terminalId || typeof terminalId !== 'string') {
      console.error('üö® [TERMINAL] Invalid terminalId for data buffering:', terminalId);
      return;
    }

    // Validate terminal exists before buffering data
    if (!this._terminals.has(terminalId)) {
      console.warn(
        `‚ö†Ô∏è [TERMINAL] Attempting to buffer data for non-existent terminal: ${terminalId}`
      );
      return;
    }

    if (!this._dataBuffers.has(terminalId)) {
      this._dataBuffers.set(terminalId, []);
      console.log(`üìä [TERMINAL] Created new data buffer for terminal: ${terminalId}`);
    }

    const buffer = this._dataBuffers.get(terminalId);
    if (!buffer) {
      console.error('üö® [TERMINAL] Buffer creation failed for terminal:', terminalId);
      this._dataBuffers.set(terminalId, []);
      return;
    }

    // ‚úÖ CRITICAL: Add terminal ID validation to each data chunk
    const validatedData = this._validateDataForTerminal(terminalId, data);
    buffer.push(validatedData);

    console.log(
      `üìä [TERMINAL] Data buffered for ${terminalId}: ${data.length} chars (buffer size: ${buffer.length})`
    );

    // Flush immediately if buffer is full or data is large
    if (buffer.length >= this.MAX_BUFFER_SIZE || data.length > 1000) {
      this._flushBuffer(terminalId);
    } else {
      this._scheduleFlush(terminalId);
    }
  }

  /**
   * ‚úÖ NEW: Validate data belongs to specific terminal
   * Prevents cross-terminal data contamination
   */
  private _validateDataForTerminal(terminalId: string, data: string): string {
    // Basic validation - could be enhanced with more sophisticated checks
    if (data.includes('\x1b]0;') && !data.includes(terminalId)) {
      // Window title escape sequences might contain terminal context
      console.log(`üîç [TERMINAL] Window title detected for ${terminalId}`);
    }

    // Return data as-is for now, but this method provides a hook for future validation
    return data;
  }

  private _scheduleFlush(terminalId: string): void {
    if (!this._dataFlushTimers.has(terminalId)) {
      const timer = setTimeout(() => {
        this._flushBuffer(terminalId);
      }, this.DATA_FLUSH_INTERVAL);
      this._dataFlushTimers.set(terminalId, timer);
    }
  }

  private _flushBuffer(terminalId: string): void {
    // ‚úÖ CRITICAL FIX: Strict terminal ID validation before flushing
    if (!terminalId || typeof terminalId !== 'string') {
      console.error('üö® [TERMINAL] Invalid terminalId for buffer flushing:', terminalId);
      return;
    }

    // Double-check terminal still exists
    if (!this._terminals.has(terminalId)) {
      console.warn(`‚ö†Ô∏è [TERMINAL] Cannot flush buffer for removed terminal: ${terminalId}`);
      // Clean up orphaned buffer and timer
      this._dataBuffers.delete(terminalId);
      const timer = this._dataFlushTimers.get(terminalId);
      if (timer) {
        clearTimeout(timer);
        this._dataFlushTimers.delete(terminalId);
      }
      return;
    }

    const timer = this._dataFlushTimers.get(terminalId);
    if (timer) {
      clearTimeout(timer);
      this._dataFlushTimers.delete(terminalId);
    }

    const buffer = this._dataBuffers.get(terminalId);
    if (buffer && buffer.length > 0) {
      const combinedData = buffer.join('');
      buffer.length = 0; // Clear buffer

      // ‚úÖ CRITICAL: Additional validation before emitting data
      const terminal = this._terminals.get(terminalId);
      if (!terminal) {
        console.error(`üö® [TERMINAL] Terminal disappeared during flush: ${terminalId}`);
        return;
      }

      // Send to CLI Agent detection service with validation
      try {
        this._cliAgentService.detectFromOutput(terminalId, combinedData);
      } catch (error) {
        console.warn(`‚ö†Ô∏è [TERMINAL] CLI Agent detection failed for ${terminalId}:`, error);
      }

      // ‚úÖ EMIT DATA WITH STRICT TERMINAL ID ASSOCIATION
      console.log(
        `üì§ [TERMINAL] Flushing data for terminal ${terminal.name} (${terminalId}): ${combinedData.length} chars`
      );
      this._dataEmitter.fire({
        terminalId: terminalId, // Ensure exact ID match
        data: combinedData,
        timestamp: Date.now(), // Add timestamp for debugging
        terminalName: terminal.name, // Add terminal name for validation
      });
    }
  }

  private _flushAllBuffers(): void {
    for (const terminalId of this._dataBuffers.keys()) {
      this._flushBuffer(terminalId);
    }
  }

  /**
   * ÂÖ®„Å¶„ÅÆ„Çø„Éº„Éü„Éä„É´„ÇíÈùû„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åô„Çã
   */
  private _deactivateAllTerminals(): void {
    for (const term of this._terminals.values()) {
      term.isActive = false;
    }
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„Éá„Éº„Çø„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÅÆ„Åø„ÇíË°å„ÅÜÔºà„Éó„É≠„Çª„Çπ„ÅØkill„Åó„Å™„ÅÑÔºâ
   */
  private _cleanupTerminalData(terminalId: string): void {
    log('üßπ [TERMINAL] === CLEANUP TERMINAL DATA START ===');
    log('üßπ [TERMINAL] Cleaning up terminal data:', terminalId);
    
    // Log terminal info before deletion
    const terminal = this._terminals.get(terminalId);
    if (terminal) {
      log('üßπ [TERMINAL] Deleting terminal:', {
        id: terminalId,
        name: terminal.name,
        number: terminal.number,
        exists: this._terminals.has(terminalId)
      });
    } else {
      log('‚ö†Ô∏è [TERMINAL] Terminal not found in map for cleanup:', terminalId);
    }
    
    log('üßπ [TERMINAL] Before deletion - terminals count:', this._terminals.size);
    log('üßπ [TERMINAL] Before deletion - terminal IDs:', Array.from(this._terminals.keys()));
    
    // Clean up data buffers for this terminal
    this._flushBuffer(terminalId);
    this._dataBuffers.delete(terminalId);
    const timer = this._dataFlushTimers.get(terminalId);
    if (timer) {
      clearTimeout(timer);
      this._dataFlushTimers.delete(terminalId);
    }

    // CLI Agent cleanup handled by service
    this._cliAgentService.handleTerminalRemoved(terminalId);

    // Remove from terminals map
    const deletionResult = this._terminals.delete(terminalId);
    log('üßπ [TERMINAL] Terminal deletion from map:', deletionResult ? 'SUCCESS' : 'FAILED');
    
    log('üßπ [TERMINAL] After deletion - terminals count:', this._terminals.size);
    log('üßπ [TERMINAL] After deletion - terminal IDs:', Array.from(this._terminals.keys()));

    this._terminalRemovedEmitter.fire(terminalId);

    log('üßπ [TERMINAL] Terminal data cleaned up:', terminalId);
    log('üßπ [TERMINAL] Remaining terminals:', Array.from(this._terminals.keys()));
    log('üßπ [TERMINAL] Remaining terminal numbers:', Array.from(this._terminals.values()).map(t => ({ id: t.id, number: t.number })));

    // Force check if terminals map is actually empty and can create should return true
    if (this._terminals.size === 0) {
      log('‚úÖ [TERMINAL] All terminals deleted - canCreate should return TRUE');
    }

    // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éº„Éü„Éä„É´„Å†„Å£„ÅüÂ†¥Âêà„ÄÅÂà•„ÅÆ„Çø„Éº„Éü„Éä„É´„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åô„Çã
    this._updateActiveTerminalAfterRemoval(terminalId);
    
    // Force state notification update
    log('üßπ [TERMINAL] Notifying state update after cleanup...');
    this._notifyStateUpdate();
    log('üßπ [TERMINAL] === CLEANUP TERMINAL DATA END ===');
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„ÇíÂâäÈô§„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶‰ªñ„ÅÆ„Çø„Éº„Éü„Éä„É´„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åô„Çã
   */
  private _removeTerminal(terminalId: string): void {
    log('üóëÔ∏è [TERMINAL] Removing terminal:', terminalId);

    // Get terminal instance before removal
    const terminal = this._terminals.get(terminalId);

    // Kill the terminal process if it's still running (safety check)
    if (terminal) {
      try {
        terminal.pty.kill();
        log('üóëÔ∏è [TERMINAL] Process killed during removal:', terminalId);
      } catch (error) {
        console.warn('‚ö†Ô∏è [TERMINAL] Error killing process during removal:', error);
      }
    }

    // Clean up terminal data
    this._cleanupTerminalData(terminalId);
  }

  /**
   * „Çø„Éº„Éü„Éä„É´ÂâäÈô§Âæå„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çø„Éº„Éü„Éä„É´Êõ¥Êñ∞Âá¶ÁêÜ
   */
  private _updateActiveTerminalAfterRemoval(terminalId: string): void {
    if (this._activeTerminalManager.isActive(terminalId)) {
      const remaining = getFirstValue(this._terminals);
      if (remaining) {
        this._activeTerminalManager.setActive(remaining.id);
        remaining.isActive = true;
        log('üîÑ [TERMINAL] Set new active terminal:', remaining.id);
      } else {
        this._activeTerminalManager.clearActive();
        log('üîÑ [TERMINAL] No remaining terminals, cleared active');
      }
    }
  }

  /**
   * Check if CLI Agent is active in a terminal
   */
  public isCliAgentConnected(terminalId: string): boolean {
    const agentState = this._cliAgentService.getAgentState(terminalId);
    return agentState.status === 'connected';
  }

  /**
   * Check if CLI Agent is running in a terminal (CONNECTED or DISCONNECTED)
   */
  public isCliAgentRunning(terminalId: string): boolean {
    const agentState = this._cliAgentService.getAgentState(terminalId);
    return agentState.status !== 'none';
  }

  /**
   * Get currently globally active CLI Agent
   */
  public getCurrentGloballyActiveAgent(): { terminalId: string; type: string } | null {
    return this._cliAgentService.getConnectedAgent();
  }

  /**
   * üö® NEW: Refresh CLI Agent state (fallback for file reference issues)
   */
  public refreshCliAgentState(): boolean {
    return this._cliAgentService.refreshAgentState();
  }

  /**
   * Get the last executed command for a terminal („Ç∑„É≥„Éó„É´Âåñ„ÅßÁÑ°ÂäπÂåñ)
   */
  public getLastCommand(_terminalId: string): string | undefined {
    return undefined; // „Ç∑„É≥„Éó„É´Âåñ„Åß„Ç≥„Éû„É≥„ÉâÂ±•Ê≠¥„ÅØÁÑ°ÂäπÂåñ
  }

  /**
   * Handle terminal output for CLI Agent detection (public API)
   */
  public handleTerminalOutputForCliAgent(terminalId: string, data: string): void {
    this._cliAgentService.detectFromOutput(terminalId, data);
  }

  /**
   * Get the active CLI Agent type for a terminal
   */
  public getAgentType(terminalId: string): string | null {
    const agentState = this._cliAgentService.getAgentState(terminalId);
    return agentState.agentType;
  }

  /**
   * Get all active CLI Agents
   */
  public getConnectedAgents(): Array<{ terminalId: string; agentInfo: { type: string } }> {
    const connectedAgent = this._cliAgentService.getConnectedAgent();
    return connectedAgent
      ? [
          {
            terminalId: connectedAgent.terminalId,
            agentInfo: { type: connectedAgent.type },
          },
        ]
      : [];
  }

  /**
   * Get the map of disconnected agents for full state sync
   */
  public getDisconnectedAgents(): Map<
    string,
    { type: 'claude' | 'gemini'; startTime: Date; terminalName?: string }
  > {
    return this._cliAgentService.getDisconnectedAgents();
  }

  /**
   * Get the connected agent terminal ID
   */
  public getConnectedAgentTerminalId(): string | null {
    const connectedAgent = this._cliAgentService.getConnectedAgent();
    return connectedAgent ? connectedAgent.terminalId : null;
  }

  /**
   * Get the connected agent type
   */
  public getConnectedAgentType(): 'claude' | 'gemini' | null {
    const connectedAgent = this._cliAgentService.getConnectedAgent();
    return connectedAgent ? (connectedAgent.type as 'claude' | 'gemini') : null;
  }

  /**
   * ÊâãÂãï„ÅßAI AgentÊé•Á∂ö„ÇíÂàá„ÇäÊõø„Åà„Çã
   * Issue #122: AI AgentÊé•Á∂öÂàá„ÇäÊõø„Åà„Éú„Çø„É≥Ê©üËÉΩ
   */
  public switchAiAgentConnection(terminalId: string): {
    success: boolean;
    reason?: string;
    newStatus: 'connected' | 'disconnected' | 'none';
    agentType: string | null;
  } {
    const terminal = this._terminals.get(terminalId);
    if (!terminal) {
      return {
        success: false,
        reason: 'Terminal not found',
        newStatus: 'none',
        agentType: null,
      };
    }

    // Delegate to the CLI Agent service
    return this._cliAgentService.switchAgentConnection(terminalId);
  }

  /**
   * Write to PTY with validation and error handling
   */
  private _writeToPtyWithValidation(
    terminal: TerminalInstance,
    data: string
  ): { success: boolean; error?: string } {
    // Prefer ptyProcess over pty for consistency
    const ptyInstance = terminal.ptyProcess || terminal.pty;

    // Comprehensive validation
    if (!ptyInstance) {
      return { success: false, error: 'No PTY instance available' };
    }

    if (typeof ptyInstance.write !== 'function') {
      return { success: false, error: 'PTY instance missing write method' };
    }

    // Check if PTY process is still alive
    if (
      terminal.ptyProcess &&
      typeof terminal.ptyProcess === 'object' &&
      'killed' in terminal.ptyProcess &&
      (terminal.ptyProcess as any).killed
    ) {
      return { success: false, error: 'PTY process has been killed' };
    }

    try {
      ptyInstance.write(data);
      return { success: true };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: `Write failed: ${errorMessage}` };
    }
  }

  /**
   * Attempt to recover from PTY write failure
   */
  private _attemptPtyRecovery(terminal: TerminalInstance, data: string): boolean {
    console.warn('‚ö†Ô∏è [RECOVERY] Attempting PTY recovery for terminal:', terminal.id);

    // Try alternative PTY instance if available
    const alternatives = [terminal.ptyProcess, terminal.pty].filter(Boolean);

    for (const ptyInstance of alternatives) {
      if (ptyInstance && typeof ptyInstance.write === 'function') {
        try {
          // Double-check that this instance wasn't already tried
          if (ptyInstance === (terminal.ptyProcess || terminal.pty)) {
            continue; // Skip the same instance that already failed
          }

          ptyInstance.write(data);
          console.log('‚úÖ [RECOVERY] PTY write recovered using alternative instance');

          // Update the terminal to use the working instance
          if (ptyInstance === terminal.pty) {
            terminal.ptyProcess = undefined; // Clear the failing instance
          }

          return true;
        } catch (recoveryError) {
          console.warn('‚ö†Ô∏è [RECOVERY] Alternative PTY instance also failed:', recoveryError);
        }
      }
    }

    // If all alternatives failed, log the failure
    console.error('‚ùå [RECOVERY] All PTY recovery attempts failed for terminal:', terminal.id);
    return false;
  }

  /**
   * Resize PTY with validation and error handling
   */
  private _resizePtyWithValidation(
    terminal: TerminalInstance,
    cols: number,
    rows: number
  ): { success: boolean; error?: string } {
    // Validate dimensions first
    if (cols <= 0 || rows <= 0) {
      return { success: false, error: `Invalid dimensions: ${cols}x${rows}` };
    }

    if (cols > 500 || rows > 200) {
      return { success: false, error: `Dimensions too large: ${cols}x${rows}` };
    }

    // Get PTY instance
    const ptyInstance = terminal.ptyProcess || terminal.pty;

    if (!ptyInstance) {
      return { success: false, error: 'No PTY instance available' };
    }

    if (typeof ptyInstance.resize !== 'function') {
      return { success: false, error: 'PTY instance missing resize method' };
    }

    // Check if PTY process is still alive
    if (
      terminal.ptyProcess &&
      typeof terminal.ptyProcess === 'object' &&
      'killed' in terminal.ptyProcess &&
      (terminal.ptyProcess as any).killed
    ) {
      return { success: false, error: 'PTY process has been killed' };
    }

    try {
      ptyInstance.resize(cols, rows);
      log(`üìè [TERMINAL] Terminal resized: ${terminal.name} ‚Üí ${cols}x${rows}`);

      // VS Code pattern: Force shell refresh after resize
      setTimeout(() => {
        try {
          // Send SIGWINCH signal to shell process to trigger prompt refresh
          if (ptyInstance.pid) {
            log(`üîÑ [TERMINAL] Sending refresh signal to process ${ptyInstance.pid}`);
            ptyInstance.write('\x0c'); // Form feed character to refresh display
          }
        } catch (refreshError) {
          log(`‚ö†Ô∏è [TERMINAL] Failed to refresh shell for ${terminal.name}:`, refreshError);
        }
      }, 50);

      return { success: true };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: `Resize failed: ${errorMessage}` };
    }
  }

  // =================== CLI Agent Detection - MOVED TO SERVICE ===================

  // All CLI Agent detection logic has been extracted to CliAgentDetectionService
  // for better separation of concerns and testability
}

/**
 * Refactored TerminalManager using dependency injection and service composition.
 *
 * This version dramatically reduces complexity from 1600+ lines to ~400 lines
 * by delegating responsibilities to specialized services while maintaining
 * full backward compatibility with the original API.
 *
 * Architecture:
 * - TerminalLifecycleManager: Handle terminal creation/deletion
 * - CliAgentDetectionService: Manage CLI agent detection and state
 * - TerminalDataBufferingService: Handle data buffering and performance
 * - TerminalStateManager: Manage terminal state and validation
 */
export class RefactoredTerminalManager {
  // =================== Service Dependencies ===================
  private readonly lifecycleManager: ITerminalLifecycleManager;
  private readonly cliAgentService: ICliAgentDetectionService;
  private readonly bufferingService: ITerminalDataBufferingService;
  private readonly stateManager: ITerminalStateManager;

  // =================== Event Emitters (Facade) ===================
  private readonly _dataEmitter = new vscode.EventEmitter<TerminalEvent>();
  private readonly _exitEmitter = new vscode.EventEmitter<TerminalEvent>();
  private readonly _terminalCreatedEmitter = new vscode.EventEmitter<TerminalInstance>();
  private readonly _terminalRemovedEmitter = new vscode.EventEmitter<string>();
  private readonly _terminalFocusEmitter = new vscode.EventEmitter<string>();

  // =================== Operation Queue for Thread Safety ===================
  private operationQueue: Promise<void> = Promise.resolve();

  // =================== Public Events (API Compatibility) ===================
  public readonly onData = this._dataEmitter.event;
  public readonly onExit = this._exitEmitter.event;
  public readonly onTerminalCreated = this._terminalCreatedEmitter.event;
  public readonly onTerminalRemoved = this._terminalRemovedEmitter.event;
  public readonly onTerminalFocus = this._terminalFocusEmitter.event;

  // onStateUpdate will be initialized after stateManager is created
  public get onStateUpdate(): vscode.Event<unknown> {
    return this.stateManager.onStateUpdate;
  }

  // =================== Constructor with Dependency Injection ===================
  constructor(
    lifecycleManager?: ITerminalLifecycleManager,
    cliAgentService?: ICliAgentDetectionService,
    bufferingService?: ITerminalDataBufferingService,
    stateManager?: ITerminalStateManager
  ) {
    log('üîß [REFACTORED-TERMINAL-MANAGER] Initializing with dependency injection...');

    // Initialize services with defaults if not provided
    this.lifecycleManager = lifecycleManager || new TerminalLifecycleManager();
    this.cliAgentService = cliAgentService || new CliAgentDetectionService();
    this.bufferingService = bufferingService || new TerminalDataBufferingService();
    this.stateManager = stateManager || new TerminalStateManager();

    this.setupServiceIntegration();
    log('‚úÖ [REFACTORED-TERMINAL-MANAGER] Initialization complete');
  }

  // =================== Service Integration Setup ===================
  private setupServiceIntegration(): void {
    log('üîó [REFACTORED-TERMINAL-MANAGER] Setting up service integration...');

    // Connect lifecycle events to state management
    this.lifecycleManager.onTerminalCreated((terminal) => {
      this.stateManager.updateTerminalState([terminal]);
      this._terminalCreatedEmitter.fire(terminal);
    });

    this.lifecycleManager.onTerminalRemoved((terminalId) => {
      this.cliAgentService.handleTerminalRemoved(terminalId);
      this.bufferingService.clearBuffer(terminalId);
      this._terminalRemovedEmitter.fire(terminalId);
    });

    this.lifecycleManager.onTerminalExit((event) => {
      this._exitEmitter.fire(event);
    });

    // Connect data buffering to CLI agent detection and output
    this.bufferingService.addFlushHandler((terminalId, data) => {
      // CLI Agent detection on buffered data
      this.cliAgentService.detectFromOutput(terminalId, data);

      // Emit buffered data
      this._dataEmitter.fire({ terminalId, data });
    });

    // Connect lifecycle data to buffering service
    this.lifecycleManager.onTerminalData((event) => {
      this.bufferingService.bufferData(event.terminalId, event.data || '');
    });

    log('‚úÖ [REFACTORED-TERMINAL-MANAGER] Service integration complete');
  }

  // =================== CLI Agent Status Integration ===================
  public get onCliAgentStatusChange(): vscode.Event<{
    terminalId: string;
    status: 'connected' | 'disconnected' | 'none';
    type: string | null;
    terminalName?: string;
  }> {
    return this.cliAgentService.onCliAgentStatusChange;
  }

  // =================== Core Terminal Operations (Delegated to Services) ===================

  /**
   * Create a new terminal - delegates to TerminalLifecycleManager
   */
  public createTerminal(): string {
    log('üîß [REFACTORED-TERMINAL-MANAGER] Creating terminal...');

    const terminalId = this.lifecycleManager.createTerminal();

    // Update state after creation
    const terminals = this.lifecycleManager.getAllTerminals();
    this.stateManager.updateTerminalState(terminals);

    log(`‚úÖ [REFACTORED-TERMINAL-MANAGER] Terminal created: ${terminalId}`);
    return terminalId;
  }

  /**
   * Focus a terminal - updates state and emits focus event
   */
  public focusTerminal(terminalId: string): void {
    log(`üéØ [REFACTORED-TERMINAL-MANAGER] Focusing terminal: ${terminalId}`);

    const terminal = this.lifecycleManager.getTerminal(terminalId);
    if (!terminal) {
      console.warn('‚ö†Ô∏è [WARN] Terminal not found for focus:', terminalId);
      return;
    }

    // Update active terminal in state manager
    this.stateManager.setActiveTerminal(terminalId);

    // Emit focus event
    this._terminalFocusEmitter.fire(terminalId);

    log(`‚úÖ [REFACTORED-TERMINAL-MANAGER] Terminal focused: ${terminal.name}`);
  }

  /**
   * Send input to terminal - delegates to lifecycle manager with CLI agent detection
   */
  public sendInput(data: string, terminalId?: string): void {
    const targetId = terminalId || this.stateManager.getActiveTerminalId();

    if (!targetId) {
      console.warn('‚ö†Ô∏è [WARN] No terminal ID provided and no active terminal');
      return;
    }

    try {
      // CLI Agent input detection
      this.cliAgentService.detectFromInput(targetId, data);

      // Delegate to lifecycle manager
      this.lifecycleManager.writeToTerminal(targetId, data);
    } catch (error) {
      console.error('‚ùå [ERROR] Failed to send input to terminal:', error);
      showErrorMessage('Failed to send input to terminal', error);
    }
  }

  /**
   * Resize terminal - delegates to lifecycle manager
   */
  public resize(cols: number, rows: number, terminalId?: string): void {
    const targetId = terminalId || this.stateManager.getActiveTerminalId();
    if (targetId) {
      this.lifecycleManager.resizeTerminal(targetId, cols, rows);
    }
  }

  /**
   * Delete terminal with validation and atomic operations
   */
  public async deleteTerminal(
    terminalId: string,
    options: {
      force?: boolean;
      source?: 'header' | 'panel' | 'command';
    } = {}
  ): Promise<DeleteResult> {
    log(
      `üóëÔ∏è [REFACTORED-TERMINAL-MANAGER] Deleting terminal: ${terminalId} (source: ${options.source || 'unknown'})`
    );

    // Queue operation to prevent race conditions
    return new Promise<DeleteResult>((resolve, reject) => {
      this.operationQueue = this.operationQueue.then(async () => {
        try {
          const result = await this.performDeleteOperation(terminalId, options);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  /**
   * Atomic delete operation with validation
   */
  private async performDeleteOperation(
    terminalId: string,
    options: {
      force?: boolean;
      source?: 'header' | 'panel' | 'command';
    }
  ): Promise<DeleteResult> {
    // Validate deletion using state manager
    if (!options.force) {
      const validation = this.stateManager.validateTerminalDeletion(terminalId);
      if (!validation.success) {
        showWarningMessage(validation.reason || 'Cannot delete terminal');
        return { success: false, reason: validation.reason };
      }
    }

    try {
      // Delegate to lifecycle manager
      await this.lifecycleManager.killTerminal(terminalId);

      // Update state
      const terminals = this.lifecycleManager.getAllTerminals();
      this.stateManager.updateTerminalState(terminals);

      log(`‚úÖ [REFACTORED-TERMINAL-MANAGER] Terminal deleted: ${terminalId}`);
      return { success: true, newState: this.stateManager.getCurrentState() };
    } catch (error) {
      log(`‚ùå [REFACTORED-TERMINAL-MANAGER] Error deleting terminal:`, error);
      return { success: false, reason: `Delete failed: ${String(error)}` };
    }
  }

  // =================== State and Query Methods (Delegated) ===================

  public hasActiveTerminal(): boolean {
    return this.stateManager.getActiveTerminalId() !== null;
  }

  public getActiveTerminalId(): string | undefined {
    return this.stateManager.getActiveTerminalId() || undefined;
  }

  public getTerminals(): TerminalInstance[] {
    return this.lifecycleManager.getAllTerminals();
  }

  public getTerminal(terminalId: string): TerminalInstance | undefined {
    return this.lifecycleManager.getTerminal(terminalId);
  }

  public setActiveTerminal(terminalId: string): void {
    this.stateManager.setActiveTerminal(terminalId);
  }

  public getCurrentState(): TerminalState {
    return this.stateManager.getCurrentState();
  }

  // =================== Legacy API Compatibility ===================

  public removeTerminal(terminalId: string): void {
    this.deleteTerminal(terminalId, { source: 'command' }).catch((error) => {
      console.error('‚ùå [LEGACY-API] Error removing terminal:', error);
    });
  }

  public canRemoveTerminal(terminalId: string): { canRemove: boolean; reason?: string } {
    const validation = this.stateManager.validateTerminalDeletion(terminalId);
    return { canRemove: validation.success, reason: validation.reason };
  }

  public safeRemoveTerminal(terminalId: string): boolean {
    const result = this.deleteTerminal(terminalId, { source: 'panel' });
    return result.then((r) => r.success).catch(() => false) as unknown as boolean;
  }

  public killTerminal(terminalId?: string): void {
    const activeId = this.stateManager.getActiveTerminalId();
    if (!activeId) {
      console.warn('‚ö†Ô∏è [WARN] No active terminal to kill');
      showWarningMessage('No active terminal to kill');
      return;
    }

    if (terminalId && terminalId !== activeId) {
      log(
        'üîÑ [REFACTORED-TERMINAL-MANAGER] Requested to kill:',
        terminalId,
        'but will kill active terminal:',
        activeId
      );
    }

    this.deleteTerminal(activeId, { force: true, source: 'command' }).catch((error) => {
      console.error('‚ùå [REFACTORED-TERMINAL-MANAGER] Error killing terminal:', error);
    });
  }

  public safeKillTerminal(_terminalId?: string): boolean {
    const activeId = this.stateManager.getActiveTerminalId();
    if (!activeId) {
      const message = 'No active terminal to kill';
      console.warn('‚ö†Ô∏è [WARN]', message);
      showWarningMessage(message);
      return false;
    }

    const result = this.deleteTerminal(activeId, { source: 'command' });
    return result.then((r) => r.success).catch(() => false) as unknown as boolean;
  }

  // =================== CLI Agent Integration (Delegated) ===================

  public isCliAgentConnected(terminalId: string): boolean {
    const agentState = this.cliAgentService.getAgentState(terminalId);
    return agentState.status === 'connected';
  }

  public isCliAgentRunning(terminalId: string): boolean {
    const agentState = this.cliAgentService.getAgentState(terminalId);
    return agentState.status !== 'none';
  }

  public getCurrentGloballyActiveAgent(): { terminalId: string; type: string } | null {
    return this.cliAgentService.getConnectedAgent();
  }

  public getLastCommand(_terminalId: string): string | undefined {
    return undefined; // Simplified - no command history tracking
  }

  public handleTerminalOutputForCliAgent(terminalId: string, data: string): void {
    this.cliAgentService.detectFromOutput(terminalId, data);
  }

  public getAgentType(terminalId: string): string | null {
    const agentState = this.cliAgentService.getAgentState(terminalId);
    return agentState.agentType;
  }

  public getConnectedAgents(): Array<{ terminalId: string; agentInfo: { type: string } }> {
    const connectedAgent = this.cliAgentService.getConnectedAgent();
    return connectedAgent
      ? [{ terminalId: connectedAgent.terminalId, agentInfo: { type: connectedAgent.type } }]
      : [];
  }

  public getDisconnectedAgents(): Map<
    string,
    { type: 'claude' | 'gemini'; startTime: Date; terminalName?: string }
  > {
    return this.cliAgentService.getDisconnectedAgents();
  }

  public getConnectedAgentTerminalId(): string | null {
    const connectedAgent = this.cliAgentService.getConnectedAgent();
    return connectedAgent ? connectedAgent.terminalId : null;
  }

  public getConnectedAgentType(): 'claude' | 'gemini' | null {
    const connectedAgent = this.cliAgentService.getConnectedAgent();
    return connectedAgent ? (connectedAgent.type as 'claude' | 'gemini') : null;
  }

  public switchAiAgentConnection(terminalId: string): {
    success: boolean;
    reason?: string;
    newStatus: 'connected' | 'disconnected' | 'none';
    agentType: string | null;
  } {
    const terminal = this.lifecycleManager.getTerminal(terminalId);
    if (!terminal) {
      return {
        success: false,
        reason: 'Terminal not found',
        newStatus: 'none',
        agentType: null,
      };
    }

    return this.cliAgentService.switchAgentConnection(terminalId);
  }

  // =================== Resource Management ===================

  public dispose(): void {
    log('üßπ [REFACTORED-TERMINAL-MANAGER] Disposing resources...');

    // Dispose all services
    this.bufferingService.dispose();
    this.cliAgentService.dispose();
    this.lifecycleManager.dispose();
    this.stateManager.dispose();

    // Dispose event emitters
    this._dataEmitter.dispose();
    this._exitEmitter.dispose();
    this._terminalCreatedEmitter.dispose();
    this._terminalRemovedEmitter.dispose();
    this._terminalFocusEmitter.dispose();

    log('‚úÖ [REFACTORED-TERMINAL-MANAGER] Disposal complete');
  }
}
