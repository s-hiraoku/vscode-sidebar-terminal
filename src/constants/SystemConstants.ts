/**
 * システム全体の定数定義
 * - 一貫した命名規則と明確な分類
 * - 型安全性を保証するenum活用
 * - 設定値の中央集権管理
 *
 * @see https://github.com/s-hiraoku/vscode-sidebar-terminal/issues/226
 *
 * このファイルは、コードベース全体で使用されるマジックナンバーを排除し、
 * 各定数の目的、計算根拠、パフォーマンスへの影響を文書化することを目的としています。
 */

// =============================================================================
// パフォーマンス関連定数
// =============================================================================

/**
 * パフォーマンスに関連する定数群
 *
 * これらの定数は、システム全体のパフォーマンス特性を決定します。
 * 値の変更は、レスポンス性、スループット、リソース使用量に影響を与えます。
 */
export const PERFORMANCE_CONSTANTS = {
  // タイムアウト設定
  /**
   * デフォルトの初期化タイムアウト (5秒)
   *
   * @rationale 通常の環境でのVS Code拡張機能の初期化は1-2秒で完了しますが、
   * 低速なマシンやネットワーク遅延を考慮して5秒に設定しています。
   *
   * @performance 初期化が5秒を超える場合、エラーとして扱われ、
   * ユーザーに通知されます。
   */
  DEFAULT_INITIALIZATION_TIMEOUT_MS: 5000,

  /**
   * デフォルトの操作タイムアウト (30秒)
   *
   * @rationale 長時間実行されるターミナルコマンド（ビルド、テストなど）を考慮して
   * 30秒に設定していますが、通常の操作は数秒以内に完了します。
   *
   * @performance タイムアウト後、操作は中断され、エラーが報告されます。
   */
  DEFAULT_OPERATION_TIMEOUT_MS: 30000,

  /**
   * WebView通信タイムアウト (3秒)
   *
   * @rationale WebViewとの通信は通常100-200msで完了しますが、
   * レンダリング遅延やGCを考慮して3秒に設定しています。
   *
   * @performance タイムアウトが発生すると、UIの応答性に影響します。
   */
  WEBVIEW_COMMUNICATION_TIMEOUT_MS: 3000,

  // バッファリング設定
  /**
   * 出力バッファのフラッシュ間隔 (16ms = 60fps)
   *
   * @rationale 60fpsは、人間の目には滑らかな動きとして認識されます。
   * これより短い間隔は、CPUリソースを無駄にする可能性があります。
   *
   * @performance 16msのフラッシュ間隔により、1秒あたり約60回の画面更新が可能です。
   * より短い間隔（4ms、8ms）は、特定のユースケース（CLI Agent、高頻度出力）で使用されます。
   *
   * @tuning
   * - 高速な応答性が必要な場合: 4-8ms
   * - 標準的な用途: 16ms (推奨)
   * - 低リソース環境: 32ms
   */
  OUTPUT_BUFFER_FLUSH_INTERVAL_MS: 16,

  /**
   * CLI Agent用の高速フラッシュ間隔 (4ms = 250fps)
   *
   * @rationale AI Agentからの出力は、ユーザーがリアルタイムで読む必要があるため、
   * より高い更新頻度（250fps）を使用して即座のフィードバックを提供します。
   *
   * @performance 4msの間隔は、1秒あたり250回の更新を可能にし、
   * タイピングのような高頻度の小さな出力に最適化されています。
   *
   * @cost より高いCPU使用率（約1.5-2倍）ですが、UXの向上が優先されます。
   */
  CLI_AGENT_FAST_FLUSH_INTERVAL_MS: 4,

  /**
   * 最大バッファサイズ (1MB)
   *
   * @rationale 1MBは、ほとんどのターミナル出力を処理するのに十分なサイズです。
   * これを超える出力は、メモリ使用量とパフォーマンスのバランスを考慮して、
   * チャンクに分割されます。
   *
   * @performance 1MBを超えるデータは、複数のフラッシュサイクルに分割され、
   * メモリスパイクを防ぎます。
   */
  MAX_BUFFER_SIZE_BYTES: 1024 * 1024,

  /**
   * バッファチャンクサイズ (50チャンク)
   *
   * @rationale 50チャンクは、小さな入力の処理速度と大きな出力の効率の
   * バランスを取るために選択されました。
   *
   * @performance 50チャンクに達すると、バッファは自動的にフラッシュされます。
   * これにより、メモリ使用量が制御され、UIの応答性が維持されます。
   *
   * @tuning
   * - 高頻度の小さな入力: 30-40
   * - バランス型: 50 (推奨)
   * - 大量出力: 70-100
   */
  MAX_BUFFER_CHUNK_COUNT: 50,

  /**
   * 大量出力の閾値 (500バイト)
   *
   * @rationale 500バイト以上のデータは「大量出力」とみなされ、
   * より積極的なバッファリング戦略が適用されます。
   *
   * @performance この閾値を超えると、フラッシュ間隔が調整され、
   * スループットが優先されます。
   */
  LARGE_OUTPUT_THRESHOLD_BYTES: 500,

  /**
   * 小さな入力の閾値 (10バイト)
   *
   * @rationale 10バイト以下のデータ（キーストローク、小さなコマンド）は
   * 即座にフラッシュされ、タイピング時の遅延を最小化します。
   *
   * @performance この閾値以下のデータは、バッファリングせずに即座に処理されます。
   */
  SMALL_INPUT_THRESHOLD_BYTES: 10,

  /**
   * 中程度の出力の閾値 (50バイト)
   *
   * @rationale 50バイト以上のデータは「中程度の出力」とみなされ、
   * 標準的なバッファリング戦略が適用されます。
   *
   * @performance この閾値を超えると、バッファが蓄積され、
   * 効率的なバッチ処理が行われます。
   */
  MODERATE_OUTPUT_THRESHOLD_BYTES: 50,

  /**
   * 即時フラッシュの閾値 (1000バイト)
   *
   * @rationale 1000バイト以上のデータは、メモリ使用量を制御するために
   * 即座にフラッシュされます。
   *
   * @performance この閾値を超えると、バッファリングせずに即座に処理されます。
   */
  IMMEDIATE_FLUSH_THRESHOLD_BYTES: 1000,

  /**
   * 超高速フラッシュ間隔 (2ms = 500fps)
   *
   * @rationale CLI AgentやREPL環境での最高の応答性を提供します。
   *
   * @performance 2msの間隔は、1秒あたり500回の更新を可能にし、
   * リアルタイムフィードバックに最適化されています。
   *
   * @cost 高いCPU使用率（約3-4倍）ですが、特定のユースケースでは必要です。
   */
  ULTRA_FAST_FLUSH_INTERVAL_MS: 2,

  // リトライ設定
  /**
   * デフォルトのリトライ回数 (3回)
   *
   * @rationale ほとんどの一時的なエラー（ネットワーク遅延、リソース競合）は
   * 3回以内に解決されます。
   */
  DEFAULT_RETRY_COUNT: 3,

  /**
   * リトライ遅延の基本値 (1秒)
   *
   * @rationale 1秒の遅延は、システムリソースの回復とユーザー体験の
   * バランスを取ります。
   */
  RETRY_DELAY_BASE_MS: 1000,

  /**
   * リトライ遅延の乗数 (2倍)
   *
   * @rationale 指数バックオフ（1s, 2s, 4s）により、システムへの負荷を
   * 段階的に軽減します。
   */
  RETRY_DELAY_MULTIPLIER: 2,

  // パフォーマンス監視
  /**
   * パフォーマンスサンプリング間隔 (1秒)
   *
   * @rationale 1秒間隔でのサンプリングは、トレンドの把握と
   * オーバーヘッドの最小化のバランスを取ります。
   */
  PERFORMANCE_SAMPLE_INTERVAL_MS: 1000,

  /**
   * パフォーマンス履歴の最大保持数 (100サンプル)
   *
   * @rationale 100サンプル（約100秒 = 1.67分）は、短期的なトレンドを
   * 把握するのに十分です。
   */
  MAX_PERFORMANCE_HISTORY_COUNT: 100,

  // メモリ管理
  /**
   * クリーンアップ間隔 (30秒)
   *
   * @rationale 30秒ごとのクリーンアップは、メモリリークの防止と
   * パフォーマンスへの影響の最小化のバランスを取ります。
   */
  CLEANUP_INTERVAL_MS: 30000,

  /**
   * 非アクティブリソースの最大保持数 (50個)
   *
   * @rationale 50個のリソースは、再利用の効率とメモリ使用量の
   * バランスを取ります。
   */
  MAX_INACTIVE_RESOURCES: 50,

  /**
   * メモリ圧迫の閾値 (100MB)
   *
   * @rationale 100MBを超えると、積極的なクリーンアップが
   * トリガーされます。
   */
  MEMORY_PRESSURE_THRESHOLD_MB: 100
} as const;

// =============================================================================
// ターミナル関連定数
// =============================================================================

/**
 * ターミナルに関連する定数群
 *
 * これらの定数は、ターミナルの動作、制限、デフォルト設定を定義します。
 */
export const TERMINAL_CONSTANTS = {
  // ターミナル制限
  /**
   * 最大ターミナル数 (5個)
   *
   * @rationale VS Codeのサイドバーのスペース制約とパフォーマンスを考慮して、
   * 5個のターミナルを上限としています。
   *
   * @performance 5個を超えると、UIの応答性とメモリ使用量に影響します。
   */
  MAX_TERMINAL_COUNT: 5,

  /**
   * 最小ターミナルID番号 (1)
   *
   * @rationale ターミナルIDは1から始まり、ユーザーに分かりやすい番号体系を提供します。
   */
  MIN_TERMINAL_ID_NUMBER: 1,

  /**
   * 最大ターミナルID番号 (5)
   *
   * @rationale MAX_TERMINAL_COUNTと一致し、一貫性のあるID管理を提供します。
   */
  MAX_TERMINAL_ID_NUMBER: 5,

  // ターミナル設定
  /**
   * デフォルトのシェルタイムアウト (10秒)
   *
   * @rationale シェルの起動は通常1-2秒で完了しますが、
   * 初回起動時のセットアップや低速なマシンを考慮して10秒に設定しています。
   *
   * @performance タイムアウト後、シェルの起動は失敗とみなされ、
   * ユーザーに通知されます。
   */
  DEFAULT_SHELL_TIMEOUT_MS: 10000,

  /**
   * デフォルトのターミナル列数 (80列)
   *
   * @rationale 80列は、ターミナルの標準的な幅であり、
   * ほとんどのCLIツールがこの幅を前提としています。
   *
   * @compatibility UNIX系システムの伝統的な標準に準拠しています。
   */
  DEFAULT_TERMINAL_COLS: 80,

  /**
   * デフォルトのターミナル行数 (24行)
   *
   * @rationale 24行は、ターミナルの標準的な高さであり、
   * サイドバーの限られたスペースに適しています。
   *
   * @note VS Codeの設定によっては、30行まで拡張される場合があります。
   */
  DEFAULT_TERMINAL_ROWS: 24,

  /**
   * 代替のデフォルト行数 (30行)
   *
   * @rationale より広いサイドバーやフルスクリーンターミナルで使用されます。
   *
   * @usage WebView環境やユーザー設定による拡張時に使用されます。
   */
  ALTERNATE_DEFAULT_ROWS: 30,

  /**
   * 最小ターミナル高さ (100ピクセル)
   *
   * @rationale 100ピクセルは、少なくとも3-4行のテキストを表示できる
   * 最小限の高さです。
   *
   * @performance これより小さい高さでは、ユーザビリティが著しく低下します。
   */
  MIN_TERMINAL_HEIGHT_PX: 100,

  /**
   * 最小ターミナル幅閾値 (50ピクセル)
   *
   * @rationale 50ピクセルは、ターミナルが有効なサイズかどうかを
   * 判定するための最小閾値です。
   *
   * @usage リサイズイベントの妥当性チェックに使用されます。
   */
  MIN_TERMINAL_SIZE_THRESHOLD_PX: 50,

  /**
   * タブストップ幅 (8スペース)
   *
   * @rationale 8スペースは、ターミナルの標準的なタブストップ幅です。
   *
   * @compatibility UNIX系システムの標準に準拠しています。
   */
  TAB_STOP_WIDTH: 8,

  // 名前とプレフィックス
  /**
   * ターミナル名のプレフィックス
   *
   * @rationale ユーザーに分かりやすい名前体系を提供します。
   * 例: "Terminal 1", "Terminal 2"
   */
  TERMINAL_NAME_PREFIX: 'Terminal',

  /**
   * ターミナルIDのプレフィックス
   *
   * @rationale 内部的な識別子として使用され、DOM要素のIDなどに使用されます。
   * 例: "terminal-1", "terminal-2"
   */
  TERMINAL_ID_PREFIX: 'terminal-',

  /**
   * 分割ターミナルのサフィックス
   *
   * @rationale 分割されたターミナルを識別するために使用されます。
   * 例: "terminal-1-split"
   */
  SPLIT_TERMINAL_SUFFIX: '-split',

  // スクロールバック設定
  /**
   * デフォルトのスクロールバック行数 (2000行)
   *
   * @rationale 2000行は、十分な履歴を提供しつつ、
   * メモリ使用量を適切に管理します。
   *
   * @performance 2000行は約100-200KBのメモリを使用します（テキスト内容による）。
   *
   * @tuning
   * - 軽量な用途: 1000行
   * - 標準的な用途: 2000行 (推奨)
   * - ヘビーな用途: 5000-10000行
   */
  DEFAULT_SCROLLBACK_LINES: 2000,

  /**
   * 最大スクロールバック行数 (10000行)
   *
   * @rationale 10000行は、メモリ使用量（約500KB-1MB）とユーザビリティの
   * バランスを取った上限値です。
   *
   * @performance 10000行を超えると、スクロールパフォーマンスとメモリ使用量に
   * 顕著な影響が出ます。
   */
  MAX_SCROLLBACK_LINES: 10000,

  /**
   * スクロールバックチャンクサイズ (100行)
   *
   * @rationale 100行ずつのチャンク処理により、大量のスクロールバックデータの
   * 保存・復元を効率化します。
   *
   * @performance チャンクサイズが大きすぎると単一処理の遅延が増加し、
   * 小さすぎるとオーバーヘッドが増加します。
   */
  SCROLLBACK_CHUNK_SIZE: 100,

  // タイミング関連
  /**
   * ターミナル削除遅延 (2秒)
   *
   * @rationale ターミナルを削除する前に2秒の猶予を設けることで、
   * ユーザーが誤操作した場合に取り消すことができます。
   *
   * @ux アニメーションと視覚的フィードバックの時間を確保します。
   */
  TERMINAL_REMOVE_DELAY_MS: 2000,

  /**
   * ヘルスチェック標準タイムアウト (3秒)
   *
   * @rationale ターミナルの健全性チェックは通常100-500msで完了しますが、
   * システム負荷を考慮して3秒に設定しています。
   *
   * @performance タイムアウト後、ターミナルは不健全とみなされ、
   * リカバリー処理が開始されます。
   */
  HEALTH_CHECK_TIMEOUT_MS: 3000,

  /**
   * セーフモード時のヘルスチェックタイムアウト (2秒)
   *
   * @rationale セーフモード時は、より短いタイムアウトを使用して、
   * 迅速な問題検出とリカバリーを行います。
   */
  HEALTH_CHECK_TIMEOUT_SAFE_MODE_MS: 2000,

  // CLI エージェント検出
  /**
   * CLI Agent検出のデバウンス遅延 (500ms)
   *
   * @rationale 出力の連続的な変化を500msでデバウンスすることで、
   * 誤検出を防ぎ、検出精度を向上させます。
   *
   * @performance 500msは、ユーザーの入力パターンとAI Agentの
   * 出力パターンを識別するのに適切な時間です。
   */
  CLI_AGENT_DETECTION_DEBOUNCE_MS: 500,

  /**
   * CLI Agent検出パターン
   *
   * @rationale 各種CLI Agentを検出するための正規表現パターン。
   * 検出されたAgentに応じて、最適化されたバッファリング戦略が適用されます。
   */
  CLI_AGENT_PATTERNS: {
    CLAUDE_CODE: /Claude Code/i,
    GITHUB_COPILOT: /GitHub Copilot|copilot/i,
    GEMINI_CLI: /gemini|bard/i,
    GENERAL_AI: /AI|Assistant|Chat/i
  }
} as const;

// =============================================================================
// UI/UX 関連定数
// =============================================================================

/**
 * UI/UX関連の定数群
 *
 * これらの定数は、ユーザーインターフェースの外観、レイアウト、
 * アニメーション、通知などを制御します。
 *
 * @rationale
 * UIの一貫性とユーザビリティを確保するため、各種サイズ、タイミング、
 * 表示時間を標準化します。
 *
 * @ux
 * - アニメーション時間は、自然な動きと応答性のバランスを取る
 * - 通知時間は、情報の重要度に応じて調整される
 * - レイアウトサイズは、VSCode標準に準拠する
 */
export const UI_CONSTANTS = {
  // ==========================================================================
  // レイアウト関連
  // ==========================================================================

  /**
   * ヘッダーの高さ（ピクセル）
   *
   * @rationale
   * VSCodeのタブバーと同じ高さを採用し、統一感を確保
   *
   * @ux
   * 32pxは、アイコンとテキストを含むのに十分なスペースを提供
   */
  HEADER_HEIGHT_PX: 32,

  /**
   * ステータスバーの高さ（ピクセル）
   *
   * @rationale
   * VSCodeの標準ステータスバーと同じ高さ
   *
   * @ux
   * コンパクトながら情報を表示するのに十分な高さ
   */
  STATUS_BAR_HEIGHT_PX: 22,

  /**
   * 境界線の幅（ピクセル）
   *
   * @rationale
   * 1pxは最小の視覚的分離を提供
   *
   * @ux
   * 控えめで邪魔にならない境界線
   */
  BORDER_WIDTH_PX: 1,

  /**
   * 標準パディング（ピクセル）
   *
   * @rationale
   * 8の倍数を使用して一貫性のあるスペーシングを確保
   *
   * @ux
   * 要素間の適切な余白を提供
   */
  PADDING_STANDARD_PX: 8,

  /**
   * 標準マージン（ピクセル）
   *
   * @rationale
   * パディングの半分を採用し、階層的なスペーシングを実現
   *
   * @ux
   * コンパクトながら視覚的に区別可能な余白
   */
  MARGIN_STANDARD_PX: 4,

  // ==========================================================================
  // アニメーション関連
  // ==========================================================================

  /**
   * 高速アニメーション時間（ミリ秒）
   *
   * @rationale
   * 150msは、即座の応答性を感じさせつつ滑らかな動きを提供
   *
   * @ux
   * ホバーエフェクトやツールチップ表示に最適
   *
   * @tuning
   * 100ms未満: 動きが突然すぎる
   * 150ms: バランスの良い高速アニメーション
   * 200ms以上: やや遅く感じる可能性
   */
  ANIMATION_DURATION_FAST_MS: 150,

  /**
   * 標準アニメーション時間（ミリ秒）
   *
   * @rationale
   * 300msは、UIアニメーションの業界標準
   *
   * @ux
   * パネルの開閉やモーダル表示に最適
   *
   * @tuning
   * 200ms: 少し速い
   * 300ms: 標準的で自然な速度
   * 500ms: やや遅く感じる
   */
  ANIMATION_DURATION_NORMAL_MS: 300,

  /**
   * 低速アニメーション時間（ミリ秒）
   *
   * @rationale
   * 500msは、ユーザーの注意を引く必要がある重要な変更に使用
   *
   * @ux
   * エラー表示や重要な状態変更に使用
   *
   * @tuning
   * 300-400ms: 少し速い
   * 500ms: 注意を引くのに適切
   * 600ms以上: 遅すぎる可能性
   */
  ANIMATION_DURATION_SLOW_MS: 500,

  /**
   * フェードアニメーション時間（ミリ秒）
   *
   * @rationale
   * 200msは、滑らかなフェードイン/アウトに最適
   *
   * @ux
   * ステータスメッセージの表示/非表示に使用
   */
  FADE_DURATION_MS: 200,

  // ==========================================================================
  // 通知関連
  // ==========================================================================

  /**
   * 短時間通知の表示時間（ミリ秒）
   *
   * @rationale
   * 3秒は、簡単なメッセージを読むのに十分
   *
   * @ux
   * 成功メッセージや軽微な情報に使用
   *
   * @tuning
   * 2秒: 短すぎる
   * 3秒: 適切
   * 4秒: 少し長い
   */
  NOTIFICATION_DURATION_SHORT_MS: 3000,

  /**
   * 標準通知の表示時間（ミリ秒）
   *
   * @rationale
   * 5秒は、中程度の長さのメッセージに適切
   *
   * @ux
   * 一般的な情報メッセージに使用
   *
   * @tuning
   * 3-4秒: 少し短い
   * 5秒: 標準的
   * 7秒: やや長い
   */
  NOTIFICATION_DURATION_NORMAL_MS: 5000,

  /**
   * 長時間通知の表示時間（ミリ秒）
   *
   * @rationale
   * 10秒は、重要なメッセージや長いテキストに適切
   *
   * @ux
   * 警告やエラーメッセージに使用
   *
   * @tuning
   * 7秒: 少し短い
   * 10秒: 適切
   * 15秒: 長すぎる可能性
   */
  NOTIFICATION_DURATION_LONG_MS: 10000,

  /**
   * ステータスメッセージ非表示までの遅延（ミリ秒）
   *
   * @rationale
   * 2秒は、ステータスを確認するのに十分な時間
   *
   * @ux
   * 一時的なステータス表示に使用
   */
  STATUS_HIDE_DELAY_MS: 2000,

  /**
   * エラーステータス表示時間（ミリ秒）
   *
   * @rationale
   * エラーは通常より長く表示し、ユーザーが気づきやすくする
   *
   * @ux
   * エラーメッセージは5秒間表示される
   */
  ERROR_STATUS_DELAY_MS: 5000,

  /**
   * ホバー時のステータス表示遅延（ミリ秒）
   *
   * @rationale
   * 500msは、意図的なホバーと偶発的な通過を区別
   *
   * @ux
   * ツールチップやヘルプテキストの表示に使用
   */
  HOVER_STATUS_DELAY_MS: 500,

  // ==========================================================================
  // フォント設定
  // ==========================================================================

  /**
   * デフォルトフォントサイズ（ピクセル）
   *
   * @rationale
   * 14pxは、多くの環境で読みやすい標準サイズ
   *
   * @ux
   * ターミナルとUI要素の両方に使用
   */
  DEFAULT_FONT_SIZE_PX: 14,

  /**
   * 最小フォントサイズ（ピクセル）
   *
   * @rationale
   * 8pxは、視認性を維持する最小サイズ
   *
   * @ux
   * これより小さいと読みにくくなる
   */
  MIN_FONT_SIZE_PX: 8,

  /**
   * 最大フォントサイズ（ピクセル）
   *
   * @rationale
   * 72pxは、プレゼンテーションモードでも十分な大きさ
   *
   * @ux
   * アクセシビリティとデモンストレーションに対応
   */
  MAX_FONT_SIZE_PX: 72,

  /**
   * フォントサイズ変更ステップ
   *
   * @rationale
   * 1pxステップは、細かい調整を可能にする
   *
   * @ux
   * Ctrl+/Ctrl- でのズーム操作に使用
   */
  FONT_SIZE_STEP: 1,

  // ==========================================================================
  // 色テーマ
  // ==========================================================================

  /**
   * テーマ切り替えアニメーション時間（ミリ秒）
   *
   * @rationale
   * 200msは、滑らかな色の遷移を提供
   *
   * @ux
   * ダーク/ライトモード切り替え時の視覚効果
   */
  THEME_TRANSITION_DURATION_MS: 200,

  /**
   * 無効状態の不透明度
   *
   * @rationale
   * 0.6は、無効状態を明確に示しつつ内容を判別可能
   *
   * @ux
   * 無効なボタンやメニュー項目に適用
   */
  OPACITY_DISABLED: 0.6,

  /**
   * ホバー状態の不透明度
   *
   * @rationale
   * 0.8は、ホバー効果を示しつつ視認性を維持
   *
   * @ux
   * ボタンやリンクのホバー時に適用
   */
  OPACITY_HOVER: 0.8
} as const;

// =============================================================================
// 通信・メッセージング関連定数
// =============================================================================

/**
 * 通信・メッセージング関連の定数群
 *
 * これらの定数は、Extension Host ↔ WebView間の通信、
 * メッセージプロトコル、セッション管理などを制御します。
 *
 * @rationale
 * 通信の信頼性、パフォーマンス、デバッグ性を確保するため、
 * タイムアウト、リトライ、バッファサイズを標準化します。
 *
 * @performance
 * - メッセージバッファリングにより、通信オーバーヘッドを削減
 * - タイムアウト設定により、デッドロックを防止
 * - リトライメカニズムにより、一時的なエラーに対応
 */
export const COMMUNICATION_CONSTANTS = {
  // ==========================================================================
  // メッセージプロトコル
  // ==========================================================================

  /**
   * メッセージ送信タイムアウト（ミリ秒）
   *
   * @rationale
   * 5秒は、ネットワーク遅延やプロセス間通信の遅延を考慮
   *
   * @performance
   * タイムアウトにより、無限待機を防止
   *
   * @tuning
   * 3秒: 低遅延環境向け
   * 5秒: 標準的な環境
   * 10秒: 高遅延環境やデバッグ時
   */
  MESSAGE_TIMEOUT_MS: 5000,

  /**
   * メッセージ再送試行回数
   *
   * @rationale
   * 3回は、一時的なエラーに対応しつつ、永久ループを防止
   *
   * @performance
   * リトライにより、ネットワークの一時的な問題に対応
   *
   * @tuning
   * 1回: リトライなし（高速だがエラーに弱い）
   * 3回: バランスの良い設定
   * 5回: 信頼性重視（遅延増加）
   */
  MESSAGE_RETRY_COUNT: 3,

  /**
   * メッセージ再送待機時間（ミリ秒）
   *
   * @rationale
   * 1秒は、一時的な問題が解決するのを待つのに適切
   *
   * @performance
   * 待機により、連続的なエラーを防止
   */
  MESSAGE_RETRY_DELAY_MS: 1000,

  /**
   * メッセージキュー最大サイズ
   *
   * @rationale
   * 100は、メモリ使用量を制限しつつ十分なバッファを提供
   *
   * @performance
   * キューイングにより、バースト的なメッセージ送信に対応
   *
   * @tuning
   * 50: メモリ節約（小さいバッファ）
   * 100: バランスの良い設定
   * 200: 大量メッセージ対応（メモリ増加）
   */
  MESSAGE_QUEUE_MAX_SIZE: 100,

  // ==========================================================================
  // WebView通信
  // ==========================================================================

  /**
   * WebView初期化タイムアウト（ミリ秒）
   *
   * @rationale
   * 10秒は、WebViewの起動とレンダリングに十分な時間
   *
   * @performance
   * 長めのタイムアウトで、低スペック環境でも動作保証
   *
   * @tuning
   * 5秒: 高速環境向け
   * 10秒: 標準的な環境
   * 20秒: 低スペック環境やデバッグ時
   */
  WEBVIEW_INIT_TIMEOUT_MS: 10000,

  /**
   * WebView readyメッセージ待機タイムアウト（ミリ秒）
   *
   * @rationale
   * 5秒は、WebViewが完全に初期化されるまでの時間
   *
   * @performance
   * タイムアウトにより、初期化の失敗を検出
   */
  WEBVIEW_READY_TIMEOUT_MS: 5000,

  /**
   * WebView再接続試行間隔（ミリ秒）
   *
   * @rationale
   * 2秒は、再接続を試みる適切な間隔
   *
   * @performance
   * 頻繁すぎる再接続試行を防止
   */
  WEBVIEW_RECONNECT_INTERVAL_MS: 2000,

  /**
   * WebView最大再接続試行回数
   *
   * @rationale
   * 5回は、一時的な問題に対応しつつ無限ループを防止
   *
   * @performance
   * リトライ回数制限により、リソース浪費を防止
   */
  WEBVIEW_MAX_RECONNECT_ATTEMPTS: 5,

  // ==========================================================================
  // セッション管理
  // ==========================================================================

  /**
   * セッションアイドルタイムアウト（ミリ秒）
   *
   * @rationale
   * 30分は、ユーザーが一時的に離席してもセッションを維持
   *
   * @performance
   * 長時間未使用のセッションを自動的にクリーンアップ
   *
   * @tuning
   * 15分: 積極的なクリーンアップ
   * 30分: バランスの良い設定
   * 60分: 長期間セッション維持
   */
  SESSION_IDLE_TIMEOUT_MS: 30 * 60 * 1000, // 30 minutes

  /**
   * セッションハートビート間隔（ミリ秒）
   *
   * @rationale
   * 30秒は、セッションの生存確認に適切な間隔
   *
   * @performance
   * ハートビートにより、デッドセッションを検出
   */
  SESSION_HEARTBEAT_INTERVAL_MS: 30000,

  /**
   * セッションクリーンアップ間隔（ミリ秒）
   *
   * @rationale
   * 5分は、定期的なクリーンアップに適切
   *
   * @performance
   * メモリリークを防止し、リソースを解放
   */
  SESSION_CLEANUP_INTERVAL_MS: 5 * 60 * 1000 // 5 minutes
} as const;

// =============================================================================
// エラーハンドリング関連定数
// =============================================================================

/**
 * エラーハンドリング関連の定数群
 *
 * これらの定数は、エラー検出、リトライ、回復処理、
 * ログ記録などを制御します。
 *
 * @rationale
 * システムの安定性と回復力を確保するため、各種エラーハンドリング
 * パラメータを標準化します。
 *
 * @performance
 * - 適切なリトライ回数により、一時的なエラーから回復
 * - タイムアウト設定により、リソース浪費を防止
 * - エラーレート制限により、ログの肥大化を防止
 */
export const ERROR_CONSTANTS = {
  // ==========================================================================
  // リトライ制御
  // ==========================================================================

  /**
   * デフォルトリトライ回数
   *
   * @rationale
   * 3回は、一時的なエラーに対応しつつ無限ループを防止
   *
   * @performance
   * リトライにより、システムの回復力を向上
   *
   * @tuning
   * 1回: リトライなし（高速だがエラーに弱い）
   * 3回: バランスの良い設定
   * 5回: 信頼性重視（遅延増加）
   */
  DEFAULT_RETRY_COUNT: 3,

  /**
   * リトライ間隔（ミリ秒）
   *
   * @rationale
   * 1秒は、一時的な問題が解決するのを待つのに適切
   *
   * @performance
   * 指数バックオフの基本間隔として使用
   *
   * @tuning
   * 500ms: 高速リトライ
   * 1000ms: 標準的な間隔
   * 2000ms: 慎重なリトライ
   */
  RETRY_DELAY_MS: 1000,

  /**
   * 指数バックオフの最大遅延（ミリ秒）
   *
   * @rationale
   * 30秒は、リトライ間隔の上限として適切
   *
   * @performance
   * 長時間のリトライループを防止
   */
  MAX_RETRY_DELAY_MS: 30000,

  /**
   * 指数バックオフの乗数
   *
   * @rationale
   * 2は、標準的な指数バックオフアルゴリズムの乗数
   *
   * @performance
   * 各リトライで待機時間が倍増する（1秒 → 2秒 → 4秒 → ...）
   */
  RETRY_BACKOFF_MULTIPLIER: 2,

  // ==========================================================================
  // エラーレート制限
  // ==========================================================================

  /**
   * エラーログレート制限（秒）
   *
   * @rationale
   * 同じエラーを10秒に1回だけログに記録
   *
   * @performance
   * ログの肥大化とディスクI/Oを削減
   *
   * @tuning
   * 5秒: より頻繁なログ記録
   * 10秒: バランスの良い設定
   * 30秒: 積極的なレート制限
   */
  ERROR_LOG_RATE_LIMIT_SECONDS: 10,

  /**
   * エラー通知レート制限（秒）
   *
   * @rationale
   * 同じエラー通知を30秒に1回だけ表示
   *
   * @performance
   * ユーザーへの過剰な通知を防止
   */
  ERROR_NOTIFICATION_RATE_LIMIT_SECONDS: 30,

  /**
   * エラーカウンターリセット間隔（ミリ秒）
   *
   * @rationale
   * 1分ごとにエラーカウンターをリセット
   *
   * @performance
   * 短期的なエラーバーストを検出しつつ、長期的なカウントを防止
   */
  ERROR_COUNTER_RESET_INTERVAL_MS: 60000,

  // ==========================================================================
  // サーキットブレーカー
  // ==========================================================================

  /**
   * サーキットブレーカー開放しきい値
   *
   * @rationale
   * 5回連続エラーでサーキットブレーカーを開放
   *
   * @performance
   * 連続的なエラーからシステムを保護
   *
   * @tuning
   * 3回: 積極的な保護
   * 5回: バランスの良い設定
   * 10回: 寛容な設定
   */
  CIRCUIT_BREAKER_THRESHOLD: 5,

  /**
   * サーキットブレーカーリセットタイムアウト（ミリ秒）
   *
   * @rationale
   * 60秒後にサーキットブレーカーを半開状態にリセット
   *
   * @performance
   * システムの回復を試みる適切な間隔
   */
  CIRCUIT_BREAKER_RESET_TIMEOUT_MS: 60000,

  // ==========================================================================
  // タイムアウト
  // ==========================================================================

  /**
   * デフォルト操作タイムアウト（ミリ秒）
   *
   * @rationale
   * 30秒は、一般的な操作が完了するのに十分
   *
   * @performance
   * タイムアウトにより、無限待機を防止
   */
  DEFAULT_OPERATION_TIMEOUT_MS: 30000,

  /**
   * 長時間操作タイムアウト（ミリ秒）
   *
   * @rationale
   * 5分は、大量データ処理などの長時間操作に対応
   *
   * @performance
   * 長時間操作でもタイムアウトで保護
   */
  LONG_OPERATION_TIMEOUT_MS: 5 * 60 * 1000, // 5 minutes

  /**
   * クリティカル操作タイムアウト（ミリ秒）
   *
   * @rationale
   * 5秒は、重要な操作が素早く完了することを保証
   *
   * @performance
   * クリティカルパスの遅延を最小化
   */
  CRITICAL_OPERATION_TIMEOUT_MS: 5000
} as const;

// =============================================================================
// タイミング・遅延関連定数
// =============================================================================

/**
 * タイミング・遅延関連の定数群
 *
 * これらの定数は、各種遅延処理、デバウンス、スロットル、
 * ポーリング間隔などを制御します。
 *
 * @rationale
 * システム全体のタイミング制御を標準化し、パフォーマンスと
 * ユーザー体験のバランスを取ります。
 *
 * @performance
 * - デバウンスにより、不要な処理を削減
 * - スロットルにより、処理頻度を制限
 * - 適切なポーリング間隔により、リソース使用を最適化
 */
export const TIMING_CONSTANTS = {
  // ==========================================================================
  // デバウンス・スロットル
  // ==========================================================================

  /**
   * リサイズデバウンス遅延（ミリ秒）
   *
   * @rationale
   * 100msは、リサイズ操作の終了を検出するのに適切
   *
   * @performance
   * デバウンスにより、リサイズ中の過剰な処理を防止
   *
   * @ux
   * ユーザーがリサイズを完了した後、素早く反映
   *
   * @tuning
   * 50ms: より応答性が高い（CPU使用量増加）
   * 100ms: バランスの良い設定
   * 200ms: CPU負荷軽減（応答性低下）
   */
  RESIZE_DEBOUNCE_DELAY_MS: 100,

  /**
   * 入力デバウンス遅延（ミリ秒）
   *
   * @rationale
   * 300msは、ユーザーの入力が完了したかを判定するのに適切
   *
   * @performance
   * デバウンスにより、タイピング中の過剰な処理を防止
   */
  INPUT_DEBOUNCE_DELAY_MS: 300,

  /**
   * スクロールスロットル間隔（ミリ秒）
   *
   * @rationale
   * 16msは、60fpsに相当し、滑らかなスクロールを実現
   *
   * @performance
   * スロットルにより、スクロール中の処理頻度を制限
   */
  SCROLL_THROTTLE_MS: 16,

  /**
   * 検索デバウンス遅延（ミリ秒）
   *
   * @rationale
   * 500msは、ユーザーが検索クエリを入力し終えるのを待つのに適切
   *
   * @performance
   * デバウンスにより、タイピング中の不要な検索実行を防止
   */
  SEARCH_DEBOUNCE_DELAY_MS: 500,

  // ==========================================================================
  // ポーリング間隔
  // ==========================================================================

  /**
   * 状態チェックポーリング間隔（ミリ秒）
   *
   * @rationale
   * 1秒は、状態変化を検出するのに適切な間隔
   *
   * @performance
   * ポーリングにより、状態の変化を定期的に検出
   */
  STATE_CHECK_INTERVAL_MS: 1000,

  /**
   * ヘルスチェック間隔（ミリ秒）
   *
   * @rationale
   * 30秒は、システムの健全性を確認するのに適切
   *
   * @performance
   * 定期的なヘルスチェックにより、問題を早期発見
   */
  HEALTH_CHECK_INTERVAL_MS: 30000,

  /**
   * リソース監視間隔（ミリ秒）
   *
   * @rationale
   * 5秒は、CPU/メモリ使用量を監視するのに適切
   *
   * @performance
   * 頻繁すぎる監視を避けつつ、問題を検出
   */
  RESOURCE_MONITOR_INTERVAL_MS: 5000,

  // ==========================================================================
  // 遅延処理
  // ==========================================================================

  /**
   * 初期化遅延（ミリ秒）
   *
   * @rationale
   * 100msは、他のコンポーネントの初期化を待つのに適切
   *
   * @performance
   * 初期化順序の競合を防止
   */
  INIT_DELAY_MS: 100,

  /**
   * クリーンアップ遅延（ミリ秒）
   *
   * @rationale
   * 500msは、リソースを安全に解放するための猶予時間
   *
   * @performance
   * 進行中の操作が完了するのを待つ
   */
  CLEANUP_DELAY_MS: 500,

  /**
   * フォーカス遅延（ミリ秒）
   *
   * @rationale
   * 50msは、フォーカス移動を滑らかにするための短い遅延
   *
   * @ux
   * 視覚的なフィードバックを提供
   */
  FOCUS_DELAY_MS: 50,

  /**
   * WebView初期化遅延（ミリ秒）
   *
   * @rationale
   * 200msは、WebViewのレンダリングが完了するのを待つ
   *
   * @performance
   * レンダリング完了前のメッセージ送信を防止
   */
  WEBVIEW_INIT_DELAY_MS: 200,

  // ==========================================================================
  // アイドル・スリープ
  // ==========================================================================

  /**
   * アイドル検出時間（ミリ秒）
   *
   * @rationale
   * 5秒間操作がない場合、アイドル状態と判定
   *
   * @performance
   * アイドル時にリソース消費を削減
   */
  IDLE_DETECTION_MS: 5000,

  /**
   * スリープ前の待機時間（ミリ秒）
   *
   * @rationale
   * 10秒間アイドルの場合、スリープモードに移行
   *
   * @performance
   * 長時間未使用のリソースを解放
   */
  SLEEP_DELAY_MS: 10000
} as const;


// =============================================================================
// 列挙型定義 - 型安全な定数グループ
// =============================================================================

/**
 * システム状態の列挙型
 */
export enum SystemStatus {
  INITIALIZING = 'initializing',
  READY = 'ready',
  BUSY = 'busy',
  ERROR = 'error',
  DISPOSING = 'disposing',
  DISPOSED = 'disposed'
}

/**
 * ターミナル操作の種類
 */
export enum TerminalAction {
  CREATE = 'create',
  DELETE = 'delete',
  ACTIVATE = 'activate',
  RESIZE = 'resize',
  CLEAR = 'clear',
  SPLIT = 'split',
  KILL = 'kill',
  RESTART = 'restart'
}

/**
 * メッセージの重要度レベル
 */
export enum MessageSeverity {
  DEBUG = 'debug',
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

/**
 * 通知の種類
 */
export enum NotificationType {
  SUCCESS = 'success',
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error'
}

/**
 * CLIエージェントの状態
 */
export enum CliAgentStatus {
  INACTIVE = 'inactive',
  DETECTING = 'detecting',
  ACTIVE = 'active',
  PROCESSING = 'processing',
  IDLE = 'idle',
  ERROR = 'error'
}

/**
 * ターミナルの状態
 */
export enum TerminalState {
  CREATING = 'creating',
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  BUSY = 'busy',
  CLOSING = 'closing',
  CLOSED = 'closed',
  ERROR = 'error'
}

/**
 * セッション操作の種類
 */
export enum SessionOperation {
  SAVE = 'save',
  RESTORE = 'restore',
  CLEAR = 'clear',
  EXPORT = 'export',
  IMPORT = 'import'
}

/**
 * パフォーマンスメトリクスの種類
 */
export enum PerformanceMetric {
  INITIALIZATION_TIME = 'initializationTime',
  OPERATION_COUNT = 'operationCount',
  AVERAGE_OPERATION_TIME = 'averageOperationTime',
  ERROR_RATE = 'errorRate',
  MEMORY_USAGE = 'memoryUsage',
  CPU_USAGE = 'cpuUsage'
}

/**
 * リソースの種類
 */
export enum ResourceType {
  EVENT_LISTENER = 'eventListener',
  TIMER = 'timer',
  INTERVAL = 'interval',
  SUBSCRIPTION = 'subscription',
  CONNECTION = 'connection',
  STREAM = 'stream',
  OBSERVER = 'observer'
}

/**
 * 設定カテゴリ
 */
export enum ConfigurationCategory {
  TERMINAL = 'terminal',
  APPEARANCE = 'appearance',
  BEHAVIOR = 'behavior',
  PERFORMANCE = 'performance',
  ADVANCED = 'advanced',
  DEBUG = 'debug'
}

