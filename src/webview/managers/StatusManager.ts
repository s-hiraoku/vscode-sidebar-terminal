import { TERMINAL_CONSTANTS, CSS_CLASSES } from '../constants';
import { PerformanceUtils } from '../utils/PerformanceUtils';
import { DOMUtils } from '../utils/DOMUtils';
import { ErrorHandler } from '../utils/ErrorHandler';
import type { StatusType, LayoutDimensions } from '../types/webview.types';

/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„Å®„É¨„Ç§„Ç¢„Ç¶„ÉàÁÆ°ÁêÜ„ÇíÊãÖÂΩì„Åô„Çã„ÇØ„É©„Çπ
 */
export class StatusManager {
  private statusElement: HTMLElement | null = null;
  private hideTimer: number | null = null;
  private readonly DEFAULT_DISPLAY_DURATION = TERMINAL_CONSTANTS.DELAYS.STATUS_HIDE_DELAY;
  private readonly ERROR_DISPLAY_DURATION = TERMINAL_CONSTANTS.DELAYS.ERROR_STATUS_DELAY;
  private lastMessage = '';
  private lastType: StatusType = 'info';
  private isStatusVisible = false;
  private readonly STATUS_HEIGHT = TERMINAL_CONSTANTS.SIZES.STATUS_BAR_HEIGHT;
  private layoutAdjustTimer: number | null = null;

  /**
   * „Çπ„ÉÜ„Éº„Çø„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
   */
  public showStatus(message: string, type: StatusType = 'info'): void {
    try {
      this.lastMessage = message;
      this.lastType = type;

      const statusEl = this.getOrCreateStatusElement();
      statusEl.textContent = message;
      statusEl.className = `${CSS_CLASSES.STATUS} ${CSS_CLASSES[`STATUS_${type.toUpperCase()}` as keyof typeof CSS_CLASSES]}`;

      this.showStatusElement();
      this.adjustTerminalLayout(true);
      this.clearTimer();

      const autoHide = true; // TODO: Read from configuration
      if (autoHide) {
        const duration =
          type === 'error' ? this.ERROR_DISPLAY_DURATION : this.DEFAULT_DISPLAY_DURATION;
        this.hideTimer = window.setTimeout(() => {
          this.hideStatusWithAnimation();
        }, duration);
      }

      console.log(`üéØ [STATUS] [${type.toUpperCase()}] ${message}`);
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(error as Error, 'StatusManager.showStatus');
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂç≥Â∫ß„Å´ÈùûË°®Á§∫
   */
  public hideStatus(): void {
    try {
      if (this.statusElement) {
        this.statusElement.style.display = 'none';
      }
      this.clearTimer();
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(error as Error, 'StatusManager.hideStatus');
    }
  }

  /**
   * „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰ªò„Åç„Åß„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÈùûË°®Á§∫
   */
  private hideStatusWithAnimation(): void {
    try {
      if (this.statusElement) {
        this.statusElement.style.opacity = '0';
        this.statusElement.style.transform = 'translateY(-100%)';

        setTimeout(() => {
          this.hideStatusElement();
          this.adjustTerminalLayout(false);
        }, TERMINAL_CONSTANTS.DELAYS.FADE_DURATION);
      }
      this.clearTimer();
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(
        error as Error,
        'StatusManager.hideStatusWithAnimation'
      );
    }
  }

  /**
   * „É¶„Éº„Ç∂„Éº„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£ÊôÇ„Å´ÊúÄÂæå„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂÜçË°®Á§∫
   */
  public showLastStatusOnActivity(): void {
    try {
      if (this.lastMessage && this.statusElement?.style.display === 'none') {
        console.log('üì± [STATUS] Showing status due to user activity');
        this.showStatus(this.lastMessage, this.lastType);
      }
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(
        error as Error,
        'StatusManager.showLastStatusOnActivity'
      );
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„ÇπË¶ÅÁ¥†„ÇíÂèñÂæó„Åæ„Åü„ÅØ‰ΩúÊàê
   */
  private getOrCreateStatusElement(): HTMLElement {
    try {
      if (!this.statusElement) {
        this.statusElement = DOMUtils.getElement('#status');
        if (this.statusElement) {
          this.setupStatusInteraction();
          this.addStatusStyles();
        }
      }
      return this.statusElement || document.createElement('div');
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(
        error as Error,
        'StatusManager.getOrCreateStatusElement'
      );
      return document.createElement('div');
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„ÇπË¶ÅÁ¥†„ÅÆ„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥Ë®≠ÂÆö
   */
  private setupStatusInteraction(): void {
    if (!this.statusElement) return;

    try {
      // „Éû„Ç¶„Çπ„Éõ„Éê„Éº„Åß„Çø„Ç§„Éû„Éº„ÇíÂÅúÊ≠¢
      DOMUtils.addEventListenerSafe(this.statusElement, 'mouseenter', () => {
        this.clearTimer();
      });

      // „Éû„Ç¶„Çπ„É™„Éº„Éñ„Åß„Çø„Ç§„Éû„Éº„ÇíÂÜçÈñãÔºàÁü≠Á∏ÆÁâàÔºâ
      DOMUtils.addEventListenerSafe(this.statusElement, 'mouseleave', () => {
        this.hideTimer = window.setTimeout(() => {
          this.hideStatusWithAnimation();
        }, TERMINAL_CONSTANTS.DELAYS.HOVER_STATUS_DELAY);
      });

      // „ÇØ„É™„ÉÉ„ÇØ„ÅßÂç≥Â∫ß„Å´ÈùûË°®Á§∫
      DOMUtils.addEventListenerSafe(this.statusElement, 'click', () => {
        this.hideStatusWithAnimation();
      });
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(
        error as Error,
        'StatusManager.setupStatusInteraction'
      );
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„Çπ„Çπ„Çø„Ç§„É´„ÇíËøΩÂä†
   */
  private addStatusStyles(): void {
    try {
      if (!DOMUtils.exists('#status-styles')) {
        const style = DOMUtils.createElement('style', {}, { id: 'status-styles' });
        style.textContent = `
          .${CSS_CLASSES.STATUS} {
            transition: opacity 0.3s ease, transform 0.3s ease;
            cursor: pointer;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: ${this.STATUS_HEIGHT}px;
            z-index: 1000;
          }
          .${CSS_CLASSES.STATUS_INFO} {
            background: var(--vscode-statusBar-background, #007acc);
            color: var(--vscode-statusBar-foreground, #ffffff);
          }
          .${CSS_CLASSES.STATUS_SUCCESS} {
            background: var(--vscode-statusBarItem-prominentBackground, #16825d);
            color: var(--vscode-statusBarItem-prominentForeground, #ffffff);
          }
          .${CSS_CLASSES.STATUS_ERROR} {
            background: var(--vscode-errorBackground, #f14c4c);
            color: var(--vscode-errorForeground, #ffffff);
          }
          .${CSS_CLASSES.STATUS_WARNING} {
            background: var(--vscode-notificationWarning-background, #ffcc02);
            color: var(--vscode-notificationWarning-foreground, #000000);
          }
          .${CSS_CLASSES.STATUS}:hover {
            opacity: 0.8;
          }
          #terminal-body {
            transition: height 0.3s ease-out;
            overflow: hidden;
          }
          .${CSS_CLASSES.SPLIT_CONTAINER} {
            transition: height 0.3s ease-out;
          }
        `;
        document.head.appendChild(style);
      }
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(
        error as Error,
        'StatusManager.addStatusStyles'
      );
    }
  }

  /**
   * „Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
   */
  private clearTimer(): void {
    if (this.hideTimer !== null) {
      window.clearTimeout(this.hideTimer);
      this.hideTimer = null;
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„ÇπË¶ÅÁ¥†„ÇíË°®Á§∫
   */
  private showStatusElement(): void {
    if (this.statusElement) {
      this.statusElement.style.display = 'block';
      this.statusElement.style.opacity = '1';
      this.statusElement.style.transform = 'translateY(0)';
      this.isStatusVisible = true;
    }
  }

  /**
   * „Çπ„ÉÜ„Éº„Çø„ÇπË¶ÅÁ¥†„ÇíÈùûË°®Á§∫
   */
  private hideStatusElement(): void {
    if (this.statusElement) {
      this.statusElement.style.display = 'none';
      this.isStatusVisible = false;
      this.statusElement.style.opacity = '1';
      this.statusElement.style.transform = 'translateY(0)';
    }
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíË™øÊï¥
   */
  private adjustTerminalLayout(statusVisible: boolean): void {
    try {
      console.log(`üìê [LAYOUT] Adjusting terminal layout, status visible: ${statusVisible}`);

      const dimensions = this.calculateLayoutDimensions(statusVisible);
      if (!dimensions) return;

      this.updateTerminalBodyHeight(dimensions);
      this.adjustSplitContainersHeight(dimensions.availableHeight);
      this.resizeAllTerminals();

      console.log(
        `‚úÖ [LAYOUT] Terminal layout adjusted: ${dimensions.availableHeight}px available`
      );
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.adjustTerminalLayout'
      );
    }
  }

  /**
   * „É¨„Ç§„Ç¢„Ç¶„ÉàÂØ∏Ê≥ï„ÇíË®àÁÆó
   */
  private calculateLayoutDimensions(statusVisible: boolean): LayoutDimensions | null {
    try {
      const terminalContainer = DOMUtils.getElement('#terminal');
      const terminalHeader = DOMUtils.getElement('#terminal-header');
      const webviewHeader = DOMUtils.getElement('#webview-header');

      if (!terminalContainer) {
        console.warn('‚ö†Ô∏è [LAYOUT] Terminal container not found');
        return null;
      }

      const containerHeight = terminalContainer.clientHeight;
      const webviewHeaderHeight = webviewHeader
        ? webviewHeader.clientHeight
        : TERMINAL_CONSTANTS.SIZES.HEADER_HEIGHT;
      const terminalHeaderHeight = terminalHeader
        ? terminalHeader.clientHeight
        : TERMINAL_CONSTANTS.SIZES.TERMINAL_HEADER_HEIGHT;
      const totalHeaderHeight = webviewHeaderHeight + terminalHeaderHeight;
      const statusHeight = statusVisible ? this.STATUS_HEIGHT : 0;
      const availableHeight = containerHeight - totalHeaderHeight - statusHeight;

      return {
        containerHeight,
        headerHeight: totalHeaderHeight,
        statusHeight,
        availableHeight,
      };
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.calculateLayoutDimensions'
      );
      return null;
    }
  }

  /**
   * „Çø„Éº„Éü„Éä„É´„Éú„Éá„Ç£„ÅÆÈ´ò„Åï„ÇíÊõ¥Êñ∞
   */
  private updateTerminalBodyHeight(dimensions: LayoutDimensions): void {
    const terminalBody = DOMUtils.getElement('#terminal-body');
    if (terminalBody) {
      terminalBody.style.height = `${dimensions.availableHeight}px`;
    }
  }

  /**
   * ÂàÜÂâ≤„Ç≥„É≥„ÉÜ„Éä„ÅÆÈ´ò„Åï„ÇíË™øÊï¥
   */
  private adjustSplitContainersHeight(availableHeight: number): void {
    try {
      const splitContainers = document.querySelectorAll(`.${CSS_CLASSES.SPLIT_CONTAINER}`);
      if (splitContainers.length > 0) {
        console.log(`üìê [LAYOUT] Adjusting ${splitContainers.length} split containers`);

        const splitCount = splitContainers.length;
        const splitterHeight = TERMINAL_CONSTANTS.SIZES.SPLITTER_HEIGHT;
        const totalSplitterHeight = (splitCount - 1) * splitterHeight;
        const terminalHeight = Math.floor((availableHeight - totalSplitterHeight) / splitCount);

        splitContainers.forEach((container) => {
          (container as HTMLElement).style.height = `${terminalHeight}px`;
        });
      }
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.adjustSplitContainersHeight'
      );
    }
  }

  /**
   * ÂÖ®„Çø„Éº„Éü„Éä„É´„Çí„É™„Çµ„Ç§„Ç∫
   */
  private resizeAllTerminals(): void {
    try {
      // „É°„Ç§„É≥„Çø„Éº„Éü„Éä„É´„ÅÆ„É™„Çµ„Ç§„Ç∫
      const windowWithManager = window as unknown as Record<string, unknown> & {
        terminalManager?: {
          terminal?: { fit?: () => void };
          fitAddon?: { fit: () => void };
          secondaryTerminal?: { fit?: () => void };
          secondaryFitAddon?: { fit: () => void };
          terminals?: Map<string, { fitAddon: { fit: () => void } }>;
        };
      };

      const terminalManager = windowWithManager.terminalManager;
      if (terminalManager?.terminal && terminalManager?.fitAddon) {
        setTimeout(() => {
          terminalManager.fitAddon?.fit();
        }, 100);
      }

      // „Çª„Ç´„É≥„ÉÄ„É™„Çø„Éº„Éü„Éä„É´„ÅÆ„É™„Çµ„Ç§„Ç∫
      if (terminalManager?.secondaryTerminal && terminalManager?.secondaryFitAddon) {
        setTimeout(() => {
          terminalManager.secondaryFitAddon?.fit();
        }, 100);
      }

      // Ë§áÊï∞„Çø„Éº„Éü„Éä„É´„ÅÆ„É™„Çµ„Ç§„Ç∫
      if (terminalManager?.terminals) {
        terminalManager.terminals.forEach((terminalData) => {
          if (terminalData.fitAddon) {
            setTimeout(() => {
              terminalData.fitAddon.fit();
            }, 100);
          }
        });
      }
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.resizeAllTerminals'
      );
    }
  }

  /**
   * „É¨„Ç§„Ç¢„Ç¶„ÉàÁÆ°ÁêÜ„ÅÆÂàùÊúüÂåñ
   */
  public initializeLayoutManagement(): void {
    try {
      this.setupLayoutResizeObserver();

      const debouncedAdjustLayout = PerformanceUtils.debounce(() => {
        this.adjustTerminalLayout(this.isStatusVisible);
      }, TERMINAL_CONSTANTS.DELAYS.RESIZE_DEBOUNCE_DELAY);

      DOMUtils.addEventListenerSafe(
        window as unknown as HTMLElement,
        'resize',
        debouncedAdjustLayout
      );

      console.log('üìê [LAYOUT] Layout management initialized');
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.initializeLayoutManagement'
      );
    }
  }

  /**
   * „É¨„Ç§„Ç¢„Ç¶„Éà„É™„Çµ„Ç§„Ç∫„Ç™„Éñ„Ç∂„Éº„Éê„Éº„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
   */
  private setupLayoutResizeObserver(): void {
    try {
      const terminalContainer = DOMUtils.getElement('#terminal');
      if (!terminalContainer) return;

      const resizeObserver = new ResizeObserver(
        PerformanceUtils.debounce(() => {
          console.log('üìê [LAYOUT] Container resized, readjusting layout');
          this.adjustTerminalLayout(this.isStatusVisible);
        }, TERMINAL_CONSTANTS.DELAYS.RESIZE_DEBOUNCE_DELAY)
      );

      resizeObserver.observe(terminalContainer);
      console.log('üìê [LAYOUT] Layout resize observer set up');
    } catch (error) {
      ErrorHandler.getInstance().handleLayoutError(
        error as Error,
        'StatusManager.setupLayoutResizeObserver'
      );
    }
  }

  /**
   * „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
   */
  public dispose(): void {
    try {
      this.clearTimer();
      if (this.layoutAdjustTimer !== null) {
        window.clearTimeout(this.layoutAdjustTimer);
        this.layoutAdjustTimer = null;
      }
      this.statusElement = null;
    } catch (error) {
      ErrorHandler.getInstance().handleGenericError(error as Error, 'StatusManager.dispose');
    }
  }
}
