/**
 * Refactored Message Manager - Uses MessageHandlerFactory to eliminate switch statement duplication
 * Provides cleaner, more maintainable message handling architecture
 */

import { webview as log } from '../../utils/logger';
import { WebViewFontSettings } from '../../types/shared';
import { IMessageManager, IManagerCoordinator } from '../interfaces/ManagerInterfaces';
import {
  showSessionRestoreStarted,
  showSessionRestoreProgress,
  showSessionRestoreCompleted,
  showSessionRestoreError,
  showSessionSaved,
  showSessionSaveError,
  showSessionCleared,
  showSessionRestoreSkipped,
} from '../utils/NotificationUtils';
import { MessageHandlerFactory, MessageValidators } from '../handlers/MessageHandlerFactory';

interface MessageCommand {
  command: string;
  cliAgentStatus?: {
    activeTerminalName: string | null;
    status: 'connected' | 'disconnected' | 'none';
    agentType: string | null;
    terminalId?: string;
  };
  [key: string]: unknown;
}

export class RefactoredMessageManager implements IMessageManager {
  private messageQueue: unknown[] = [];
  private isProcessingQueue = false;
  private queueLock = false;
  private highPriorityQueue: unknown[] = [];

  private handlerFactory = new MessageHandlerFactory();

  constructor() {
    this.initializeHandlers();
    log('📨 [REFACTORED-MESSAGE] Message manager initialized with factory pattern');
  }

  /**
   * Initialize all message handlers using the factory pattern
   */
  private initializeHandlers(): void {
    // Initialize message
    this.handlerFactory.registerHandler('init', this.handleInitMessage.bind(this), {
      priority: 'high',
      requiresCoordinator: true,
    });

    // Output message
    this.handlerFactory.registerHandler('output', this.handleOutputMessage.bind(this), {
      priority: 'high',
      requiresCoordinator: true,
      validation: MessageValidators.combine(MessageValidators.hasTerminalId, MessageValidators.hasData),
    });

    // Terminal removed
    this.handlerFactory.registerHandler('terminalRemoved', this.handleTerminalRemovedMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasTerminalId,
    });

    // Clear terminal
    this.handlerFactory.registerHandler('clear', this.handleClearTerminalMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasTerminalId,
    });

    // Font settings update
    this.handlerFactory.registerHandler('fontSettingsUpdate', this.handleFontSettingsUpdateMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasFontSettings,
    });

    // Settings response
    this.handlerFactory.registerHandler('settingsResponse', this.handleSettingsResponseMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasSettings,
    });

    // Terminal created
    this.handlerFactory.registerHandler('terminalCreated', this.handleTerminalCreatedMessage.bind(this), {
      requiresCoordinator: true,
    });

    // New terminal
    this.handlerFactory.registerHandler('newTerminal', this.handleNewTerminalMessage.bind(this), {
      requiresCoordinator: true,
    });

    // Focus terminal
    this.handlerFactory.registerHandler('focusTerminal', this.handleFocusTerminalMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasTerminalId,
    });

    // State update
    this.handlerFactory.registerHandler('stateUpdate', this.handleStateUpdateMessage.bind(this), {
      requiresCoordinator: true,
    });

    // CLI Agent status update
    this.handlerFactory.registerHandler('cliAgentStatusUpdate', this.handleClaudeStatusUpdateMessage.bind(this), {
      requiresCoordinator: true,
    });

    // CLI Agent full state sync
    this.handlerFactory.registerHandler('cliAgentFullStateSync', this.handleCliAgentFullStateSyncMessage.bind(this), {
      requiresCoordinator: true,
    });

    // Session management handlers
    this.handlerFactory.registerHandler('sessionRestore', this.handleSessionRestoreMessage.bind(this), {
      requiresCoordinator: true,
    });

    this.handlerFactory.registerHandler('sessionRestoreStarted', this.handleSessionRestoreStartedMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionRestoreProgress', this.handleSessionRestoreProgressMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionRestoreCompleted', this.handleSessionRestoreCompletedMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionRestoreError', this.handleSessionRestoreErrorMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionSaved', this.handleSessionSavedMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionSaveError', this.handleSessionSaveErrorMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionCleared', this.handleSessionClearedMessage.bind(this), {
      requiresCoordinator: false,
    });

    this.handlerFactory.registerHandler('sessionRestoreSkipped', this.handleSessionRestoreSkippedMessage.bind(this), {
      requiresCoordinator: false,
    });

    // Scrollback handlers
    this.handlerFactory.registerHandler('getScrollback', this.handleGetScrollbackMessage.bind(this), {
      requiresCoordinator: true,
    });

    this.handlerFactory.registerHandler('restoreScrollback', this.handleRestoreScrollbackMessage.bind(this), {
      requiresCoordinator: true,
    });

    this.handlerFactory.registerHandler('scrollbackProgress', this.handleScrollbackProgressMessage.bind(this), {
      requiresCoordinator: false,
    });

    // Panel location handlers
    this.handlerFactory.registerHandler('panelLocationUpdate', this.handlePanelLocationUpdateMessage.bind(this), {
      requiresCoordinator: true,
      validation: MessageValidators.hasLocationParam,
    });

    this.handlerFactory.registerHandler('requestPanelLocationDetection', this.handleRequestPanelLocationDetectionMessage.bind(this), {
      requiresCoordinator: true,
    });

    // Terminal serialization handlers
    this.handlerFactory.registerHandler('requestTerminalSerialization', this.handleRequestTerminalSerializationMessage.bind(this), {
      requiresCoordinator: true,
    });

    this.handlerFactory.registerHandler('restoreTerminalSerialization', this.handleRestoreTerminalSerializationMessage.bind(this), {
      requiresCoordinator: true,
    });

    log(`📋 [REFACTORED-MESSAGE] Initialized ${this.handlerFactory.getStats().totalHandlers} message handlers`);
  }

  /**
   * Handle incoming messages using factory pattern
   */
  public handleMessage(message: MessageEvent, coordinator: IManagerCoordinator): void {
    try {
      const msg = message.data as MessageCommand;
      log(`📨 [REFACTORED-MESSAGE] Received: ${msg.command}`);

      // Use factory to execute handler
      void this.handlerFactory.executeHandler(msg, coordinator);
    } catch (error) {
      log('❌ [REFACTORED-MESSAGE] Error handling message:', error, message);
    }
  }

  /**
   * Add message to appropriate queue
   */
  public addToQueue(message: unknown): void {
    const msg = message as MessageCommand;
    
    if (this.handlerFactory.isHighPriority(msg.command)) {
      this.highPriorityQueue.push(message);
      log(`⚡ [REFACTORED-MESSAGE] Added high priority message to queue: ${msg.command}`);
    } else {
      this.messageQueue.push(message);
      log(`📋 [REFACTORED-MESSAGE] Added message to queue: ${msg.command}`);
    }
  }

  // All the existing handler methods remain the same, but now they're registered
  // with the factory instead of being called from a switch statement
  private handleInitMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('🎯 [REFACTORED-MESSAGE] Handling init message');
    const terminalIds = msg.terminalIds as string[] || [];
    
    if (terminalIds.length > 0) {
      log(`🎯 [REFACTORED-MESSAGE] Received ${terminalIds.length} terminal IDs from extension`);
      
      for (const terminalId of terminalIds) {
        log(`🎯 [REFACTORED-MESSAGE] Processing terminal: ${terminalId}`);
        coordinator.createTerminal?.(terminalId, `Terminal ${terminalId}`, {});
      }
    }

    this.sendInitCompleteResponse();
  }

  private handleOutputMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const terminalId = msg.terminalId as string;
    const data = msg.data as string;
    
    log(`📤 [REFACTORED-MESSAGE] Processing output for terminal ${terminalId}: ${data.length} chars`);

    const terminalInstance = coordinator.getTerminalInstance(terminalId);
    if (terminalInstance?.terminal) {
      terminalInstance.terminal.write(data);
    }
  }

  private handleTerminalRemovedMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const terminalId = msg.terminalId as string;
    log(`🗑️ [REFACTORED-MESSAGE] Handling terminal removed: ${terminalId}`);
    coordinator.removeTerminal?.(terminalId);
  }

  private handleClearTerminalMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const terminalId = msg.terminalId as string;
    log(`🧹 [REFACTORED-MESSAGE] Clearing terminal: ${terminalId}`);
    
    const terminalInstance = coordinator.getTerminalInstance(terminalId);
    if (terminalInstance?.terminal) {
      terminalInstance.terminal.clear();
    }
  }

  private handleFontSettingsUpdateMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const fontSettings = msg.fontSettings as WebViewFontSettings;
    log('🔤 [REFACTORED-MESSAGE] Updating font settings:', fontSettings);
    coordinator.updateFontSettings?.(fontSettings);
  }

  private handleSettingsResponseMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('⚙️ [REFACTORED-MESSAGE] Processing settings response');
    coordinator.updateSettings?.(msg.settings);
  }

  private handleTerminalCreatedMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('🆕 [REFACTORED-MESSAGE] Handling terminal created message');
    const terminalId = msg.terminalId as string;
    const terminalName = msg.terminalName as string || 'New Terminal';
    coordinator.createTerminal?.(terminalId, terminalName, {});
  }

  private handleNewTerminalMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('➕ [REFACTORED-MESSAGE] Handling new terminal request');
    // Request new terminal from extension
    this.postMessageToExtension({ command: 'requestNewTerminal' });
  }

  private handleFocusTerminalMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const terminalId = msg.terminalId as string;
    log(`🎯 [REFACTORED-MESSAGE] Focusing terminal: ${terminalId}`);
    coordinator.switchToTerminal?.(terminalId);
  }

  private handleStateUpdateMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('📊 [REFACTORED-MESSAGE] Processing state update');
    coordinator.handleStateUpdate?.(msg.state);
  }

  private handleClaudeStatusUpdateMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('🤖 [REFACTORED-MESSAGE] Handling CLI Agent status update');
    if (msg.cliAgentStatus) {
      const status = msg.cliAgentStatus;
      coordinator.updateCliAgentStatus?.(
        status.terminalId || '',
        status.status,
        status.agentType
      );
    }
  }

  private handleCliAgentFullStateSyncMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    log('🔄 [REFACTORED-MESSAGE] Handling CLI Agent full state sync');
    coordinator.syncCliAgentFullState?.(msg);
  }

  // Session management handlers
  private handleSessionRestoreMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('🔄 [REFACTORED-MESSAGE] Handling session restore');
    // Implementation for session restore
  }

  private handleSessionRestoreStartedMessage(msg: MessageCommand): void {
    log('🏁 [REFACTORED-MESSAGE] Session restore started');
    showSessionRestoreStarted(msg.terminalCount as number || 0);
  }

  private handleSessionRestoreProgressMessage(msg: MessageCommand): void {
    log('📈 [REFACTORED-MESSAGE] Session restore progress');
    showSessionRestoreProgress(msg.completed as number || 0, msg.total as number || 0);
  }

  private handleSessionRestoreCompletedMessage(msg: MessageCommand): void {
    log('✅ [REFACTORED-MESSAGE] Session restore completed');
    showSessionRestoreCompleted(msg.restoredCount as number || 0);
  }

  private handleSessionRestoreErrorMessage(msg: MessageCommand): void {
    log('❌ [REFACTORED-MESSAGE] Session restore error');
    showSessionRestoreError(msg.error as string || 'Unknown error');
  }

  private handleSessionSavedMessage(msg: MessageCommand): void {
    log('💾 [REFACTORED-MESSAGE] Session saved');
    showSessionSaved(msg.terminalCount as number || 0);
  }

  private handleSessionSaveErrorMessage(msg: MessageCommand): void {
    log('❌ [REFACTORED-MESSAGE] Session save error');
    showSessionSaveError(msg.error as string || 'Unknown error');
  }

  private handleSessionClearedMessage(): void {
    log('🧹 [REFACTORED-MESSAGE] Session cleared');
    showSessionCleared();
  }

  private handleSessionRestoreSkippedMessage(msg: MessageCommand): void {
    log('⏭️ [REFACTORED-MESSAGE] Session restore skipped');
    showSessionRestoreSkipped(msg.reason as string || 'Unknown reason');
  }

  // Scrollback handlers
  private handleGetScrollbackMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('📜 [REFACTORED-MESSAGE] Handling get scrollback request');
    // Implementation for scrollback retrieval
  }

  private handleRestoreScrollbackMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('🔄 [REFACTORED-MESSAGE] Handling restore scrollback request');
    // Implementation for scrollback restoration
  }

  private handleScrollbackProgressMessage(_msg: MessageCommand): void {
    log('📈 [REFACTORED-MESSAGE] Scrollback progress update');
    // Show progress notification
  }

  // Panel location handlers
  private handlePanelLocationUpdateMessage(msg: MessageCommand, coordinator: IManagerCoordinator): void {
    const location = msg.location as string;
    log(`📍 [REFACTORED-MESSAGE] Panel location update: ${location}`);
    coordinator.updatePanelLocation?.(location);
  }

  private handleRequestPanelLocationDetectionMessage(coordinator: IManagerCoordinator): void {
    log('🔍 [REFACTORED-MESSAGE] Requesting panel location detection');
    coordinator.detectPanelLocation?.();
  }

  // Terminal serialization handlers
  private handleRequestTerminalSerializationMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('📋 [REFACTORED-MESSAGE] Handling request terminal serialization');
    // Implementation for terminal serialization request
  }

  private handleRestoreTerminalSerializationMessage(_msg: MessageCommand, _coordinator: IManagerCoordinator): void {
    log('🔄 [REFACTORED-MESSAGE] Handling restore terminal serialization');
    // Implementation for terminal serialization restoration
  }

  /**
   * Post message to extension
   */
  private postMessageToExtension(message: unknown): void {
    try {
      const windowWithApi = window as Window & {
        vscodeApi?: {
          postMessage: (message: unknown) => void;
        };
      };
      const api = windowWithApi.vscodeApi;
      if (api) {
        api.postMessage(message);
      } else {
        log('⚠️ [REFACTORED-MESSAGE] VS Code API not available');
      }
    } catch (error) {
      log('❌ [REFACTORED-MESSAGE] Error posting message to extension:', error);
    }
  }

  /**
   * Send init complete response
   */
  private sendInitCompleteResponse(): void {
    this.postMessageToExtension({
      command: 'test',
      type: 'initComplete',
      timestamp: Date.now(),
    });
  }

  /**
   * Get factory statistics
   */
  public getFactoryStats() {
    return this.handlerFactory.getStats();
  }

  /**
   * Dispose and cleanup
   */
  public dispose(): void {
    log('🧹 [REFACTORED-MESSAGE] Disposing refactored message manager');
    
    this.handlerFactory.clear();
    this.messageQueue = [];
    this.highPriorityQueue = [];
    this.isProcessingQueue = false;
    this.queueLock = false;

    log('✅ [REFACTORED-MESSAGE] Refactored message manager disposed');
  }
}